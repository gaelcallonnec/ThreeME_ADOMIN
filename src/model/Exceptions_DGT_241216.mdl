##########################################################
################ MODIFICATIONS EVAL SNBC3 ################
##########################################################


#### Création de variables de sorties ####
MAT = sum (MAT[s] if MAT[s]<>0 on s)
PMAT*MAT = sum (PMAT[s]*MAT[s] if MAT[s]<>0 on s)

# calcul salaire superbrut agrege
w_s_spb  =  sum(W_S[s]*(1 + TCSE[s])*L_S[s]/L_s on s)
w_spb = w_s_spb * L_s/L + w_se*L_se/L

# calcul CL multiplié par PROG_L pour tableaux de resultats pour comparaison avec Mesange.
CL_S_bis[s] =  CL_S[s]* PROG_L[s] if L_S[s] > 0
CL_SE_bis[s] = CL_SE[s]* PROG_L[s] if L_SE[s] > 0
CL_S_bis = (sum(CL_S_bis[s] * L_S[s] on s))/L_S
CL_SE_bis = (sum(CL_SE_bis[s] * L_SE[s] on s))/L_SE
CL_bis  * L  = ( CL_S_bis  * L_S  + CL_SE_bis  * L_SE )

# ajout des intérêts au stock de dette des ménages (uniquement pour affichage, cahier de variantes)
# pour le GOV ils sont inclus dans le deficit qui est utilise pour calculer la dette
# pas d'accumulation des intérêts passés dans la dette pcq ils sont déduits déjà de EXP?

DEBT_REHAB_Val_tot[h,ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_REHAB[h,ecl] ) * DEBT_REHAB_Val[h,ecl]{-1} +  DEBT_REHAB_Val_tot[h,ecl]{-1}*R_I_REHAB[h,ecl]{-1} + R_LOAN_REHAB[h,ecl] * RENOV_VAL_apCEE[ecl] )+ (@year =< %baseyear) * DEBT_REHAB_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )
					
DEBT_NewB_Val_tot[h,ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_NewBUIL[h,ecl] ) * DEBT_NewB_Val[h,ecl]{-1} + DEBT_NewB_Val_tot[h,ecl]{-1}*R_I_NewBUIL[h,ecl]{-1}  + R_LOAN_NewBUIL[h,ecl] * PNewBUIL[h,ecl] * NewBUIL[h,ecl] ) + (@year =< %baseyear) * DEBT_NewB_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )

DEBT_AUTO_Val_tot[h,ecl] = (@year > %baseyear)*( DEBT_auto_Val[h,ecl]{-1}*(1 - R_RMBS_AUTO[h,ecl]) + DEBT_AUTO_Val_tot[h,ecl]{-1}*R_I_AUTO[h,ecl]{-1} + R_LOAN_AUTO[h,ecl]*PNewAuto[h,ecl]*NewAuto[h,ecl]*(1 - R_SUB_AUTO[h,ecl]) ) + (@year <= %baseyear)*(DEBT_auto_Val[h,ecl]{-1}*(1 + STEADYSTATE(1,1)))

						 
# Calcul de l'endettement des SNF
@over d(R_G) = 1/8 * d(R) + (1 - 1/8) * d(R_G{-1})

DEBT_SNF_VAL[s] = (1+R_SNF[s]{-1}) * DEBT_SNF_VAL[s]{-1} + PIA[s]*IA[s]
R_SNF[s] = 1/4 * d(R[s]) + (1 - 1/4) * R_SNF[s]{-1}

DEBT_SNF_VAL=sum(DEBT_SNF_VAL[s] on s)

DEBT_SNF_ENER = sum(DEBT_SNF_VAL[se] on se)

#### CALAGE DU MODELE ####

@over d(log(WD[cm]))=  (d(log(Xexo[cm])) - d(SUBST_X[cm]) )*(@year<=2019) + (log(1+REAL_GDP_GROWTH_DGT) + choc_WD[cm] )*(@year>2019)    if Xexo[cm] <> 0   

@over DSD_base[c] = SUPPLY_USE_DOM($c,(NELEMSET(1,1)+1)+NELEMSET(5,1)+NELEMSET(7,1)+NELEMSET(1,1)+5) * REAL_GDP_INDEX_DGT

@over DSM_base[c] = SUPPLY_USE_FOREIGN($c,1+NELEMSET(5,1)+NELEMSET(7,1)+NELEMSET(1,1)+5) * REAL_GDP_INDEX_DGT

#### VERIFICATIONS SUPPLEMENTAIRES ####

verif_CH_val = PCH * CH - (sum(PCH[c] * CH[c] on c))
Verif_G_val = PG * G - (sum(PG[c] * G[c] on c))  
Verif_I_val = PI * I - (sum(PI[c] * I[c] on c)) 
verif_X_val = PX * X - (sum(PX[c] * X[c] on c))
verif_DS_val = PDS * DS - (sum(PDS[c] * DS[c] on c))
verif_M_val = PM * M - (sum(PM[c] * M[c] on c)) 


#### AJOUTS CHOCS DGT POUR CAHIER DE VARIANTES####

 @over PROG_K[s] = PROG_K[s]{-1} * (1 + GR_PROG_K[s] + CHOC_K + CHOC_PGF)
 @over PROG_L[s] = PROG_L[s]{-1} * (1 + GR_PROG_L[s] + CHOC_L + CHOC_PGF)
 @over PROG_E[s] = PROG_E[s]{-1} * (1 + GR_PROG_E[s] + CHOC_E + CHOC_PGF) 
 @over PROG_L = (sum(PROG_L[s] * L[s] on s))/L

 @over Prog_L_03 = (@year<=2022) * (1 + GR_Prog_L_03 + CHOC_L + CHOC_PGF) * Prog_L_03{-1} + _
              (@year>2022) * ( Prog_L_03{-1} * (1 + dlog(Prog_L_VP) + GR_Prog_L_03 + CHOC_L + CHOC_PGF))
 
 @over PROG_K_03  = (@year<=2022) * PROG_K_03{-1}  * ( 1  + GR_PROG_K_03 + CHOC_K + CHOC_PGF) + _
            (@year>2022) * ( Prog_K_03{-1} * (1 + dlog(Prog_K_VP) + GR_Prog_K_03 + CHOC_K + CHOC_PGF))
 
 
##### MODIFICATION DU COUT DU CAPITAL ##### avec cette spécification, 2Mtep de plus. suppression du déséquilibre comptable

@over CK[s] = PK[s] * (  R[s] - d(P)/P{-1} + Tdec[s]) if K[s] > 0

 
#### MODIFICATION DE LA REGLE DE TAYLOR #####

@over d(R_DIR) = 1* d(infl_FR) + d(R_ADD) + (@year>2022) * (- 0 * d(Unr_tot) + 0* d(infl_FR) )
@over d(R_e) = 0.05 * d(R_e{-1}) + 0.65 * d(R{-1}) + 0.3 * d(R_n)

#### AJOUT D'UN CHOC DE TAUX D'INTERET (GREENIUM) #####

@over R  = 1 * R_n  + ( 1  - 1 )  * ( R(- 1)  + d(R_e) ) + R_exo
@over d(R[s]) = d(R) + d(R_exo[s])

##### INVESTISSEMENT DES SECTEURS NON ENERGETIQUES #####


#Réécriture du choc CSC en niveau
Choc_CSC_niv[sne] = CSC_cost * EMS_CSC[sne] #attention dans l'utilisation de ce type de choc : l'unité n'est pas la même que celle de la variable dans laquelle il intervient ensuite (ici CO2 contre euros pour l'investissement) 

# Investissement notionnel  sans choc
d(log(IA_notionnel_noshock[sne])) = dlog(Y[sne]) + d(SUBST_K[sne]) - dlog(PROG_K[sne])  if IA_n[sne] <> 0 where s in 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20

# Investissement notionnel avec le choc en niveau
IA_notionnel[sne] = IA_notionnel_noshock[sne] + (@year > 2019) * (Choc_CSC_niv[sne]) if IA_n[sne] <> 0 

# Investissement observé 
d(log(IA_n_des[sne]))  = d(IMP_BUD_niv_bis[sne]) + ( ADJUST(1  , 1)  * dlog(IA_n_des[sne]{-1})  + 1.8  * dlog(Y[sne]) + 0.28  * ( log(IA_notionnel[sne]{-1}) + IMP_BUD_niv_bis[sne]{-1} - log(IA_n_des[sne]{-1}) )  + ADJUST(1, 4) * 0 * d(SUBST_K[sne]) ) if IA_n[sne] <> 0 
@over d(log(IA_n[sne])) = ( @year <= 2019 )  * ( ( IAexo[sne] > 0 )  * ( dlog(IAexo[sne]) ) )  + ( @year > 2019 )  * (d(log(IA_n_des[sne]))) if IA_n[sne] <> 0 

# stock de capital notionnel
@over K_n[sne] = (1 - Tdec[sne]) * K_n[sne]{-1} + IA_notionnel[sne] + IMP_BUD_niv[sne] + IMP_BUD_niv_MDE[sne] if K[sne] <> 0 where s in 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20

# exception secteur 19 (chocs specifiques)

@over d(log(IA_notionnel_noshock_19)) = d(log(Y_19)) + ( 1  - AME_renov_19 ) * d(SUBST_K_19) - d(log(PROG_K_19))  + AME_renov_19 * ( d(SUBST_K_NE_19) )

@over d(log(IA_n_des_19))  = d(IMP_BUD_niv_bis_19) + ( ADJUST(1  , 1)  * dlog(IA_n_des_19{-1})  + 1.8  * dlog(Y_19) + 0.28  * ( log(IA_notionnel_19{-1}) + IMP_BUD_niv_bis_19{-1} - log(IA_n_des_19{-1}) )  + ADJUST(1, 4) *0* AME_renov_19 * d(SUBST_K_19) + (1- AME_renov_19) * ( 0*d(SUBST_K_NE_19)) ) if IA_n_19 <> 0 

d(log(IA_n_bis_19)) = ( @year <= 2019 )  * ( ( IAexo_19 > 0 )  * ( dlog(IAexo_19) ) )  + ( @year > 2019 )  * (d(log(IA_n_des_19)))


# investissements dans les infrastructures de recharge de VE
@over d(log(Inv_IRVE)) = d(log(Auto_elec))
@over IRVE = (1 - tdec_IRVE) * IRVE{-1} + Inv_IRVE

# investissements énergétiques
d(log(I_MDE_notionnel_19)) = d(log(Y_19)) - d(log(PROG_K_19)) + d(SUBST_K_E_19)
@over d(log(I_MDE_19)) = AME_renov_19  * ( d(I_MDE_shock_exo_19) + ADJUST(1  , 1)  * dlog(I_MDE_19{-1})  + 1.8  * dlog(Y_19)  + 0.28 * (log(I_MDE_notionnel_19{-1}) + I_MDE_shock_exo_19{-1} - log(I_MDE_19{-1}))  + ADJUST(1  , 4)  * 0 * d(SUBST_K_E_19)) + (1 - AME_renov_19)  * d(log(I_MDE_exo_19))

@over IA_n_19 = IA_n_bis_19 + (@year > 2019) * ((I_MDE_19-@elem(I_MDE_19, 2018)) + (Inv_IRVE-@elem(Inv_IRVE, 2018)) + sobre_19 * IA_n_19{-1})
# est-ce qu'il est volontaire de considerer que la difference de I_MDE qu'a partir de 2018. AME_renov = 0 depuis 2016

# exception secteur 20 (chocs specifiques)
@over K_NE_n_20 = (@year<= 2019 )*(K_n_20 > 0)*K_NE_n_20{-1}*(K_n_20/K_n_20{-1})+ (@year>2019)*(K_n_20 - K_E_n_20) 
@over K_E_n_20 = (@year<= 2019 )*(K_n_20 > 0)*K_E_n_20{-1}*(K_n_20/K_n_20{-1})+ (@year>2019)*(K_E_n_20{-1}*(1 - tdec_20) + I_MDE_20)    

@over d(log(IA_notionnel_noshock_20)) = d(log(Y_20)) + ( 1  - AME_renov_20 ) * d(SUBST_K_20) - d(log(PROG_K_20))  + AME_renov_20 * ( d(SUBST_K_NE_20) )
@over d(log(IA_n_des_20))  = d(IMP_BUD_niv_bis_20) + ( ADJUST(1  , 1)  * dlog(IA_n_des_20{-1})  + 1.8  * dlog(Y_20) + 0.28  * ( log(IA_notionnel_20{-1} + Choc_DACCS_niv{-1}) + IMP_BUD_niv_bis_20{-1} - log(IA_n_des_20{-1}) )  + ADJUST(1, 4) *0* AME_renov_20 * d(SUBST_K_20) + (1- AME_renov_20) * ( 0*d(SUBST_K_NE_20)) ) if IA_n_20 <> 0 

# Reecriture du choc en niveau

Choc_DACCS_niv  = DACCS_cost * EMS_DACCS  
d(log(IA_n_bis_20)) = ( @year <= 2019 )  * ( ( IAexo_20 > 0 )  * ( dlog(IAexo_20) ) )  + ( @year > 2019 )  * (d(log(IA_n_des_20)))

# Integration des chocs en niveau
d(log(I_MDE_notionnel_20)) = d(log(Y_20)) - d(log(PROG_K_20)) + d(SUBST_K_E_20)
@over d(log(I_MDE_20)) = AME_renov_20  * (d(I_MDE_shock_exo_20) + ADJUST(1  , 1)  * dlog(I_MDE_20{-1})  + 1.8  * dlog(Y_20)  + 0.28 * (log(I_MDE_notionnel_20{-1}) + I_MDE_shock_exo_20{-1} - log(I_MDE_20{-1}))  + ADJUST(1  , 4)  * 0 * d(SUBST_K_E_20)) + (1 - AME_renov_20)  * d(log(I_MDE_exo_20))

@over IA_n_20 = IA_n_bis_20 + (@year > 2019) * ((I_MDE_20-@elem(I_MDE_20, 2018)) + (INV_Road-@elem(INV_Road, 2018)))

# exceptions transport marchandises
# équation ADEME à réintégrer
@over dlog(K_n[road])  = ( @year <= 2019 )  * ( K_n[road] > 0 )  * dlog(K[road])  + ( @year > 2019 ) * dlog(K[road] )

# isolation des dynamiques de l'investissement en biens 03 et 12 des secteurs [road]
dlog(IA_n_noshock_03[road]) = dlog(IA_n[road])
dlog(IA_n_noshock_12[road]) = dlog(IA_n[road])


#### PRIX DES IMPORTATIONS ####

# On remplace: Price/equation 5.40PM[c] = TC*PWD[c] if M[c] <> 0

# Reproduction des dynamiques de Mésange

# biens agricoles
d(log(PM_n_01)) = (0.32 * dlog(TC * PWD_01) + 0.10 * dlog(TC * PWD_01{-1}) + 0.46 * dlog(PYQS_01) - 0.32 * (log(PM_n_01{-1}) - 0.75 * log(PYQS_01{-1}) - (1-0.75) * log(TC * PWD_01{-1}))) if PYQS_01 <>0

@over PM_01 = (TC * PWD_01)*(@year<=2019) + ((1+d(PM_n_01)/PM_n_01{-1})*PM_01{-1})*(@year>2019) #if PM_01_n{-1} <> 0

# biens manufactures (industrie hors construction)
   
 d(log(PM_n[sind])) = (0.32 * dlog(TC * PWD[sind]) + 0.10 * dlog(TC * PWD[sind]{-1}) + 0.46 * dlog(PYQS[sind]) _
   - 0.32 * ( log(PM_n[sind]{-1}) - 0.75 * log(PYQS[sind]{-1}) - (1-0.75) * log(TC * PWD[sind]{-1}))) 
  
  @over PM[sind] = (TC * PWD[sind])*(@year<=2019) + ((1+d(PM_n[sind])/PM_n[sind]{-1})*PM[sind]{-1})*(@year>2019) #if PM_n[sind]{-1}<>0
# on enleve la constante et le terme pdm_em de l équation

# services exposes (transports sauf 15 et business services? )

d(log(PM_n[cservex])) = (0.55 * dlog(PYQS[cservex]) + 0.15 * dlog(PYQS[cservex]{-1}) - 0.26 * ( log(PM_n[cservex]{-1}) - 0.75 * log(PYQS[cservex]{-1}) - (1-0.75) * log(TC * PWD[cservex]{-1}))) if PYQS[cservex]<>0

@over PM[cservex] = (TC * PWD[cservex])*(@year<=2019) + ((1+d(PM_n[cservex])/PM_n[cservex]{-1})*PM[cservex]{-1})*(@year>2019) #if PM_n[cservex]{-1}<>0

# biens energetiques
# production du secteur marchand en valeur
YQS_SM = sum(YQS[cbienmar] on cbienmar)
# prix production du secteur marchand
PYQS_SM = sum(YQS[cbienmar]*PYQS[cbienmar]/YQS_SM on cbienmar)

d(log(PM_n[ce]))=(0.74 * dlog(TC * PWD[ce]) - 0.97 * (log(PM_n[ce]{-1}) - 0.17 * log(PYQS_SM{-1}) - (1-0.17)*log(TC * PWD[ce]{-1})))
 @over PM[ce] = (TC * PWD[ce])*(@year<=2019) + ((1+d(PM_n[ce])/PM_n[ce]{-1})*PM[ce]{-1})*(@year>2019) #if PM_n[ce]{-1}<>0
# comme on prend le prix du baril pour tous les secteurs et que les séries de PM par secteur sont identiques jusqu en 2006 alors on a des PM identiques pour tous les secteurs nrj.


#### VOLUMES DES IMPORTATIONS ####

#consommations intermédiaires non-énergétiques
#relation de long terme modifiée de manière à converger vers la propension moyenne à importer
	#industrie ok 

  d(log(MATM_des_n[cdai,sne])) = 1.55*dlog(QD[cdai]) - 0.41*(log(MATM_des_n[cdai,sne]{-1}) - log(MAT[cdai,sne]{-1}) + 0.48*(log(PMATM[cdai]{-1})-log(PMATD[cdai]{-1}))) if MATM_des_n[cdai,sne] <> 0

 MATM_des[cdai,sne]  = (CIMexo[cdai,sne])*(@year<=2019) _
                        + ((MATM_des[cdai,sne]{-1}*(1+d(MATM_des_n[cdai,sne])/MATM_des_n[cdai,sne]{-1})>0)*(MATM_des[cdai,sne]{-1}*(1+d(MATM_des_n[cdai,sne])/MATM_des_n[cdai,sne]{-1}))+(MATM_des[cdai,sne]{-1}*(1+d(MATM_des_n[cdai,sne])/MATM_des_n[cdai,sne]{-1})<=0)*0.00001)*(@year>2019) if MATM_des[cdai,sne] <> 0
 @over MATM[cdai,sne] = (CIMexo[cdai,sne])*(@year<=2019) _
                        + ((MAT[cdai,sne] - MATM_des[cdai,sne]>0)*(MATM_des[cdai,sne])+(MAT[cdai,sne] - MATM_des[cdai,sne]<=0)*(MAT[cdai,sne] -0.00001))*(@year>2019) if MATM[cdai,sne] <> 0
 @over MATD[cdai,sne]  = (CIDexo[cdai,sne])*(@year<=2019) _
                        + ((MAT[cdai,sne]-MATM[cdai,sne]>0)*(MAT[cdai,sne]-MATM[cdai,sne])+(MAT[cdai,sne]-MATM[cdai,sne]<=0)*0.0001)*(@year>2019) if MATD[cdai,sne] <> 0

 MAT_bis_dgt[cdai,sne] = MATD[cdai,sne] + MATM[cdai,sne] 
 verif_MAT_dgt[cdai,sne] = MAT[cdai,sne] - MAT_bis_dgt[cdai,sne] 

		#dans AME-AMS
 @over MATD_12_13  = ( CIDexo_12_13 )  * ( @year <= 2019 )  + ( MATD_12_13{-1} * ( 1  + ( MAT_12_13 > 0 )  * ( d(MAT_12_13)  / MAT_12_13{-1}  + d(SUBST_MATD_12_13) ) ) - Prop_M_PAC * d(choc_PAC) * MATD_12_13{-1}/MAT_12_13{-1} ) * ( @year > 2019 )   
 @over MATM_12_13  = (CIMexo_12_13)*(@year<=2019) _
                        + ((MAT_12_13-MATD_12_13>0)*(MAT_12_13-MATD_12_13)+(MAT_12_13-MATD_12_13<=0)*0.0001)*(@year>2019) if MATM_12_13 <> 0
 @over MATD_12_03  = (CIDexo_12_03)*(@year<=2019) + _
                         (MATD_12_03{-1}*(1+(MAT_12_03>0)*(d(MAT_12_03)/MAT_12_03{-1} + d(SUBST_MATD_12_03)))-(1-AME_battery)*(CHD_03/CH_03)*d(Pbattery* Newauto_elec[h]/1000)) *(@year>2019) if MATD_12_03 <> 0
 @over MATM_12_03  = (CIMexo_12_03)*(@year<=2019) _
                        + ((MAT_12_03-MATD_12_03>0)*(MAT_12_03-MATD_12_03)+(MAT_12_03-MATD_12_03<=0)*0.0001)*(@year>2019) if MATM_12_03 <> 0

	#services
 d(log(MATM_des_n[cservex,sne])) = 0.25*dlog(MATM_des_n[cservex,sne]{-1}) + 1.18*dlog(QD[cservex]) - 0.34*d(log(PMATM[cservex]{-1})-log(PMATD[cservex]{-1})) - 0.49*(log(MATM_des_n[cservex,sne]{-1}) - log(MAT[cservex,sne]{-1}) + 0.69*(log(PMATM[cservex]{-1})-log(PMATD[cservex]{-1}))) if MATM_des_n[cservex,sne] <> 0
 MATM_des[cservex,sne] = (CIMexo[cservex,sne])*(@year<=2019) _
                        + ((MATM_des[cservex,sne]{-1}*(1+d(MATM_des_n[cservex,sne])/MATM_des_n[cservex,sne]{-1})>0)*(MATM_des[cservex,sne]{-1}*(1+d(MATM_des_n[cservex,sne])/MATM_des_n[cservex,sne]{-1}))+(MATM_des[cservex,sne]{-1}*(1+d(MATM_des_n[cservex,sne])/MATM_des_n[cservex,sne]{-1})<=0)*0.00001)*(@year>2019) if MATM_des[cservex,sne] <> 0
 @over MATM[cservex,sne] = (CIMexo[cservex,sne])*(@year<=2019) _
                        + ((MAT[cservex,sne] - MATM_des[cservex,sne]>0)*(MATM_des[cservex,sne])+(MAT[cservex,sne] - MATM_des[cservex,sne]<=0)*(MAT[cservex,sne] -0.00001))*(@year>2019) if MATM[cservex,sne] <> 0
 @over MATD[cservex,sne]  = (CIDexo[cservex,sne])*(@year<=2019) _
                        + ((MAT[cservex,sne]-MATM[cservex,sne]>0)*(MAT[cservex,sne]-MATM[cservex,sne])+(MAT[cservex,sne]-MATM[cservex,sne]<=0)*0.0001)*(@year>2019) if MATD[cservex,sne] <> 0

 MAT_bis_dgt[cservex,sne] = MATD[cservex,sne] + MATM[cservex,sne] 
 verif_MAT_dgt[cservex,sne] = MAT[cservex,sne] - MAT_bis_dgt[cservex,sne]

#consommations intermédiaires énergétiques
# attention certains EM sont exogenes: EM_24_01, ..., EM_24_06, EM_24_09, ...EM_24_20, EM_24_2303, EM_24_2308 car elles sont égales à 0

# ne tourne pas pour le bien 21 (charbon), on l exclut de la modification
# creation d une liste de biens energetiques sans bien 21 %list_com_e_no2

  d(log(EM_des_n[eno21,s])) = 1.15*d(log(QD[eno21])) - 0.96*(log(EM_des_n[eno21,s]{-1}) - log(E[eno21,s]{-1}) ) if EM_des_n[eno21,s] <> 0 
 EM_des[eno21,s] = ((E[eno21,s]-ED[eno21,s]>0)*(E[eno21,s]-ED[eno21,s])+(E[eno21,s]-ED[eno21,s]<=0)*0.0001)*(@year<=2019) _
                        + ((EM_des[eno21,s]{-1}*(1+d(EM_des_n[eno21,s])/EM_des_n[eno21,s]{-1})>0)*(EM_des[eno21,s]{-1}*(1+d(EM_des_n[eno21,s])/EM_des_n[eno21,s]{-1}))+(EM_des[eno21,s]{-1}*(1+d(EM_des_n[eno21,s])/EM_des_n[eno21,s]{-1})<=0)*0.00001)*(@year>2019) if EM_des[eno21,s] <> 0
 @over EM[eno21,s] = ((E[eno21,s]-ED[eno21,s]>0)*(E[eno21,s]-ED[eno21,s])+(E[eno21,s]-ED[eno21,s]<=0)*0.0001)*(@year<=2019) _
                        + ((E[eno21,s]-EM_des[eno21,s]>0)*(EM_des[eno21,s])+(E[eno21,s]-EM_des[eno21,s]<=0)*(E[eno21,s] -0.00001))*(@year>2019) if EM[eno21,s] <> 0
 @over ED[eno21,s]  = ((1+d(E[eno21,s])/E[eno21,s]{-1}+d(SUBST_ED[eno21,s]))*ED[eno21,s]{-1})*(@year<=2019) _
                        + ((E[eno21,s]-EM[eno21,s]>0)*(E[eno21,s]-EM[eno21,s])+(E[eno21,s]-EM[eno21,s]<=0)*0.0001)*(@year>2019) if ED[eno21,s] <> 0

 E_bis_dgt[eno21,s] = ED[eno21,s] + EM[eno21,s]
 verif_E_dgt[eno21,s] = E[eno21,s] - E_bis_dgt[eno21,s]


#deux dernières équations à clarifier, desactivees pour l instant

#conso des ménages
	#dai
 d(log(CHM_des_n[cdai])) = 1.55*dlog(QD[cdai]) - 0.41*(log(CHM_des_n[cdai]{-1}) - log(EXP[cdai]{-1}) + 0.48*(log(PCHM[cdai]{-1})-log(PCHD[cdai]{-1}))) if CHM[cdai] <> 0

 CHM_des[cdai] = CHM_des[cdai]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) _
                        + ((CHM_des[cdai]{-1}*(1+d(CHM_des_n[cdai])/CHM_des_n[cdai]{-1})>0)*(CHM_des[cdai]{-1}*(1+d(CHM_des_n[cdai])/CHM_des_n[cdai]{-1}))+(CHM_des[cdai]{-1}*(1+d(CHM_des_n[cdai])/CHM_des_n[cdai]{-1})<=0)*0.00001)*(@year>2019) if CHM[cdai] <> 0
 @over CHM[cdai] = CHM[cdai]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) _
                        + ((EXP[cdai] - CHM_des[cdai]>0)*(CHM_des[cdai])+(EXP[cdai] - CHM_des[cdai]<=0)*(EXP[cdai] -0.00001))*(@year>2019) if CHM[cdai] <> 0
 @over CHD[cdai]  = ((EXP[cdai]-CHM[cdai] > 0) * (EXP[cdai] - CHM[cdai]) + (EXP[cdai] - CHM[cdai] =< 0) * (0.00001))*(@year<=2019) _
                    + ((EXP[cdai] - CHM[cdai]>0)*(EXP[cdai] - CHM[cdai])+(EXP[cdai] - CHM[cdai]<=0)*0.00001)*(@year>2019)

 CH_bis_dgt[cdai] = CHD[cdai] + CHM[cdai]
 verif_CH_dgt[cdai] = EXP[cdai] - CH_bis_dgt[cdai]

	#services
  d(log(CHM_des_n[cservex])) = 0.25*dlog(CHM_des_n[cservex]{-1}) + 1.18*dlog(QD[cservex]) -0.43*d(log(PCHM[cservex]{-1})-log(PCHD[cservex]{-1})) - 0.49*(log(CHM_des_n[cservex]{-1}) - log(EXP[cservex]{-1}) + 0.69*(log(PCHM[cservex]{-1})-log(PCHD[cservex]{-1}))) if CHM_des_n[cservex] <> 0

 CHM_des[cservex] = CHM_des[cservex]{-1}*((1 + (QMexo[cservex]>0)*(d(QMexo[cservex])/QMexo[cservex]{-1})))*(@year<=2019) _
                        + ((CHM_des[cservex]{-1}*(1+d(CHM_des_n[cservex])/CHM_des_n[cservex]{-1})>0)*(CHM_des[cservex]{-1}*(1+d(CHM_des_n[cservex])/CHM_des_n[cservex]{-1}))+(CHM_des[cservex]{-1}*(1+d(CHM_des_n[cservex])/CHM_des_n[cservex]{-1})<=0)*0.00001)*(@year>2019) if CHM_des[cservex] <> 0
 @over CHM[cservex] = CHM[cservex]{-1}*((1 + (QMexo[cservex]>0)*(d(QMexo[cservex])/QMexo[cservex]{-1})))*(@year<=2019) _
                        + ((EXP[cservex] - CHM_des[cservex]>0)*(CHM_des[cservex])+(EXP[cservex] - CHM_des[cservex]<=0)*(EXP[cservex] -0.00001))*(@year>2019) if CHM[cservex] <> 0
 @over CHD[cservex]  = ((EXP[cservex]-CHM[cservex] > 0) * (EXP[cservex] - CHM[cservex]) + (EXPexo[cservex] - CHM[cservex] =< 0) * (0.00001))*(@year<=2019) _
                    + ((EXP[cservex] - CHM[cservex]>0)*(EXP[cservex] - CHM[cservex])+(EXP[cservex] - CHM[cservex]<=0)*0.00001)*(@year>2019)

 CH_bis_dgt[cservex] = CHD[cservex] + CHM[cservex]
 verif_CH_dgt[cservex] = EXP[cservex] - CH_bis_dgt[cservex]

	#énergies
  d(log(CHM_des_n[cepeg])) = 1.15*dlog(QD[cepeg]) - 0.96*(log(CHM_des_n[cepeg]{-1}) - log(EXP[cepeg]{-1}) ) if CHM_des_n[cepeg] <> 0

 CHM_des[cepeg] = ((EXP[cepeg]  - CHD[cepeg]>0)  * (EXP[cepeg] - CHD[cepeg])  + (EXP[cepeg]  - CHD[cepeg]<=0)  * (0.0001))*(@year<=2019) _
                        + ((CHM_des[cepeg]{-1}*(1+d(CHM_des_n[cepeg])/CHM_des_n[cepeg]{-1})>0)*(CHM_des[cepeg]{-1}*(1+d(CHM_des_n[cepeg])/CHM_des_n[cepeg]{-1}))+(CHM_des[cepeg]{-1}*(1+d(CHM_des_n[cepeg])/CHM_des_n[cepeg]{-1})<=0)*0.00001)*(@year>2019) if CHM_des[cepeg] <> 0
 @over CHM[cepeg] = ((EXP[cepeg]  - CHD[cepeg]>0)  * (EXP[cepeg] - CHD[cepeg])  + (EXP[cepeg]  - CHD[cepeg]<=0)  * (0.0001))*(@year<=2019) _
                        + ((EXP[cepeg] - CHM_des[cepeg]>0)*(CHM_des[cepeg])+(EXP[cepeg] - CHM_des[cepeg]<=0)*(EXP[cepeg] -0.00001))*(@year>2019) if CHM[cepeg] <> 0
 @over CHD[cepeg]  = ((1+((d(EXP[cepeg]))/(EXP[cepeg]{-1}) + d(SUBST_CHD[cepeg]))) * CHD[cepeg]{-1})*(@year<=2019) _
                    + ((EXP[cepeg] - CHM[cepeg]>0)*(EXP[cepeg] - CHM[cepeg])+(EXP[cepeg] - CHM[cepeg]<=0)*0.00001)*(@year>2019) if CHD[cepeg] <> 0

 CH_bis_dgt[cepeg] = CHD[cepeg] + CHM[cepeg]
 verif_CH_dgt[cepeg] = EXP[cepeg] - CH_bis_dgt[cepeg]

#conso publique
	#dai
  d(log(GM_des_n[cdai])) = 1.55*dlog(QD[cdai]) - 0.41*(log(GM_des_n[cdai]{-1}) - log(EXPG[cdai]{-1}) + 0.48*(log(PGM[cdai]{-1})-log(PGD[cdai]{-1}))) if GM_des_n[cdai] <> 0

 GM_des[cdai] = GM_des[cdai]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) _
                        + ((GM_des[cdai]{-1}*(1+d(GM_des_n[cdai])/GM_des_n[cdai]{-1})>0)*(GM_des[cdai]{-1}*(1+d(GM_des_n[cdai])/GM_des_n[cdai]{-1}))+(GM_des[cdai]{-1}*(1+d(GM_des_n[cdai])/GM_des_n[cdai]{-1})<=0)*0.00001)*(@year>2019) if GM_des[cdai] <> 0
 @over GM[cdai] = GM[cdai]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) _
                        + ((EXPG[cdai]-GM_des[cdai]>0)*(GM_des[cdai])+(EXPG[cdai]-GM_des[cdai]<=0)*(EXPG[cdai]-0.00001))*(@year>2019) if GM[cdai] <> 0
 @over GD[cdai]  = (EXPG[cdai] - GM[cdai]>0)*(EXPG[cdai] - GM[cdai])+(EXPG[cdai] - GM[cdai]<=0)*0.00001

 G_bis_dgt[cdai] = GD[cdai] + GM[cdai]
 verif_G_dgt[cdai] = EXPG[cdai] - G_bis_dgt[cdai]

	#services
  d(log(GM_n[cservex])) = 0.25*dlog(GM_n[cservex]{-1}) + 1.18*dlog(QD[cservex]) - 0.34*(log(PGM[cservex]{-1})-log(PGD[cservex]{-1})) - 0.49*(log(GM_n[cservex]{-1}) - log(EXPG[cservex]{-1}) + 0.69*(log(PGM[cservex]{-1})-log(PGD[cservex]{-1}))) if GM_n[cservex] <> 0

 @over GM[cservex] = GM[cservex]{-1}*((1 + (QMexo[cservex]>0)*(d(QMexo[cservex])/QMexo[cservex]{-1})))*(@year<=2019) _
                        + ((GM[cservex]{-1}*(1+d(GM_n[cservex])/GM_n[cservex]{-1})>0)*(GM[cservex]{-1}*(1+d(GM_n[cservex])/GM_n[cservex]{-1}))+(GM[cservex]{-1}*(1+d(GM_n[cservex])/GM_n[cservex]{-1})<=0)*0.00001)*(@year>2019) if GM[cservex] <> 0
 @over GD[cservex]  = (EXPG[cservex] - GM[cservex]>0)*(EXPG[cservex] - GM[cservex])+(EXPG[cservex] - GM[cservex]<=0)*0.00001

 G_bis_dgt[cservex] = GD[cservex] + GM[cservex]
 verif_G_dgt[cservex] = EXPG[cservex] - G_bis_dgt[cservex]

	#énergies
#Il n y a pas d importations de consommations publiques énergétiques


#investissement
	#dai
d(log(IAM_des_n[cdai,sne])) = 1.55*dlog(QD[cdai]) - 0.41*(log(IAM_des_n[cdai,sne]{-1}) - log(IA_n[cdai,sne]{-1}) + 0.48*(log(PIAM[cdai]{-1})-log(PIAD[cdai]{-1}))) if IAM_des_n[cdai,sne] <> 0

 IAM_des[cdai,sne] = IAM_des[cdai,sne]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) + ((IAM_des[cdai,sne]{-1}*(1+d(IAM_des_n[cdai,sne])/IAM_des_n[cdai,sne]{-1})>0)*(IAM_des[cdai,sne]{-1}*(1+d(IAM_des_n[cdai,sne])/IAM_des_n[cdai,sne]{-1}))+(IAM_des[cdai,sne]{-1}*(1+d(IAM_des_n[cdai,sne])/IAM_des_n[cdai,sne]{-1})<=0)*0.00001)*(@year>2019) if IAM_des[cdai,sne] <> 0
 
 @over IAM[cdai,sne] = IAM[cdai,sne]{-1}*((1 + (QMexo[cdai]>0)*(d(QMexo[cdai])/QMexo[cdai]{-1})))*(@year<=2019) + ((IA_n[cdai,sne] - IAM_des[cdai,sne]>0)*(IAM_des[cdai,sne])+(IA_n[cdai,sne] - IAM_des[cdai,sne]<=0)*(IA_n[cdai,sne]-0.00001))*(@year>2019) if IAM[cdai,sne] <> 0

 @over IAD[cdai,sne]  = (IA_n[cdai,sne] - IAM[cdai,sne]>0)*(IA_n[cdai,sne] - IAM[cdai,sne])+(IA_n[cdai,sne] - IAM[cdai,sne]<=0)*0.00001 if IAD[cdai, sne] <> 0

 IA_bis_dgt[cdai,sne] = IAD[cdai,sne] + IAM[cdai,sne]
 verif_IA_dgt[cdai,sne] = IA_n[cdai,sne] - IA_bis_dgt[cdai,sne]

	#services
 d(log(IAM_des_n[cservex,sne])) = 0.25*dlog(IAM_des_n[cservex,sne]{-1}) + 1.18*dlog(QD[cservex]) - 0.34*d(log(PIAM[cservex]{-1})-log(PIAD[cservex]{-1})) - 0.49*(log(IAM_des_n[cservex,sne]{-1}) - log(IA_n[cservex,sne]{-1}) + 0.69*(log(PIAM[cservex]{-1})-log(PIAD[cservex]{-1}))) if IAM_des_n[cservex,sne] <> 0
 
 IAM_des[cservex,sne] = IAM_des[cservex,sne]{-1}*((1 + (QMexo[cservex]>0)*(d(QMexo[cservex])/QMexo[cservex]{-1})))*(@year<=2019)  + ((IAM_des[cservex,sne]{-1}*(1+d(IAM_des_n[cservex,sne])/IAM_des_n[cservex,sne]{-1})>0)*(IAM_des[cservex,sne]{-1}*(1+d(IAM_des_n[cservex,sne])/IAM_des_n[cservex,sne]{-1}))+(IAM_des[cservex,sne]{-1}*(1+d(IAM_des_n[cservex,sne])/IAM_des_n[cservex,sne]{-1})<=0)*0.00001)*(@year>2019) if IAM_des[cservex,sne] <> 0
 
 @over IAM[cservex,sne] = IAM[cservex,sne]{-1}*((1 + (QMexo[cservex]>0)*(d(QMexo[cservex])/QMexo[cservex]{-1})))*(@year<=2019)   + ((IA_n[cservex,sne] - IAM_des[cservex,sne]>0)*(IAM_des[cservex,sne])+(IA_n[cservex,sne] - IAM_des[cservex,sne]<=0)*(IA_n[cservex,sne]-0.00001))*(@year>2019) if IAM[cservex,sne] <> 0
 
 @over IAD[cservex,sne]  = (IA_n[cservex,sne] - IAM[cservex,sne]>0)*(IA_n[cservex,sne] - IAM[cservex,sne])+(IA_n[cservex,sne] - IAM[cservex,sne]<=0)*0.00001 if IAD[cservex, sne] <> 0

 IA_bis_dgt[cservex,sne] = IAD[cservex,sne] + IAM[cservex,sne]
 verif_IA_dgt[cservex,sne] = IA_n[cservex,sne] - IA_bis_dgt[cservex,sne]

	#énergies
#Il n y a pas d importations d investissements énergétiques
####equilibre comptable OK

#### TAUX DE MARGE DES SECTEURS NON ENERGETIQUES ####

# Utilisation de la définition du taux de marge de la V3 pour tous les secteurs non-énergétiques

##! Cost share of input $f$ for sector $s$
phi_n_K[sne] = K_n[sne] * CK[sne] / (K_n[sne] * CK[sne] + L_n[sne] * PROG_L[sne] * CL[sne] + E_n[sne] * (PE[sne] + PE_CEE_n[sne] + PE_signal_bis[sne]) + MAT_n[sne] * PMAT[sne])
phi_n_L[sne] = L_n[sne] * PROG_L[sne] * CL[sne] / (K_n[sne] * CK[sne] + L_n[sne] * PROG_L[sne] * CL[sne] + E_n[sne] * (PE[sne] + PE_CEE_n[sne] + PE_signal_bis[sne]) + MAT_n[sne] * PMAT[sne])
phi_n_E[sne] = (E_n[sne] * (PE[sne] + PE_CEE_n[sne] + PE_signal_bis[sne])) / (K_n[sne] * CK[sne] + L_n[sne] * PROG_L[sne] * CL[sne] + E_n[sne] * (PE[sne] + PE_CEE_n[sne] + PE_signal_bis[sne]) + MAT_n[sne] * PMAT[sne])
phi_n_MAT[sne] = MAT_n[sne] * PMAT[sne] / (K_n[sne] * CK[sne] + L_n[sne] * PROG_L[sne] * CL[sne] + E_n[sne] * (PE[sne] + PE_CEE_n[sne] + PE_signal_bis[sne]) + MAT_n[sne] * PMAT[sne])

##! Capacité de production (fonction de production évaluée aux quantités effectives de facteurs, comme dans la V3)
d(log(YCAP[sne])) = phi_n_L[sne]{-1} * d(log(L[sne] * PROG_L[sne]) ) + phi_n_K[sne]{-1} * d(log(K[sne] * PROG_K[sne]) ) + phi_n_E[sne]{-1} * d(log(E[sne] * PROG_E[sne]) ) + phi_n_MAT[sne]{-1} * d(log(MAT[sne]) ) if YCAP[sne] <> 0

CUR_bis[sne] = Y[sne]/YCAP[sne]

d(log(CUR_test[sne])) = 0.6 * d(log(CUR_bis[sne])) + 0.4 * d(log(CUR_cible[sne])) - 0.6 * (log(CUR_test[sne]{-1}) - log(CUR_cible[sne]{-1}))

@over dlog(1+TMD_n[sne]) = (0.4 * ( dlog(Y[sne]) -dlog(Y_e[sne]{-1})))*(@year<=2019) + ((TMD_n[sne]{-1}>0.01)*(0.75 * d(log(CUR_test[sne]))) + (TMD_n[sne]{-1}<=0.01)*(0.000001)) * (@year > 2019) if Y[sne] > 0

#agrégé sne
YCAP = sum(YCAP[sne] on sne)
CUR_bis = Y/YCAP
d(log(CUR_test)) = 0.6 * d(log(CUR_bis)) + 0.4 * d(log(CUR_cible)) - 0.6 * (log(CUR_test{-1}) - log(CUR_cible{-1}))						


#### MODIFICATION DES EQUATIONS DE SALAIRES ####

# salaires notionnels - secteurs non énergétiques : terme chomage en contemporain

d(log(W_S_des_n[sne])) = 1*d(log(PVA)) + 1*d(log(PROG_L[sne])) + 1*d(log(1/((1-TCSS)*(1-TIR[H01]{-1})))) - 3.2*d(UnR_TOT)      if W_S_n[sne] <> 0

@over d(log(W_S_n[sne])) = (@year<=2019)* (1*d(log(P_e)) + d(log(CFS)) + 1*d(log(PROG_L[sne])) - 1.8*d(UnR_TOT{-1})) + (@year>2019)* d(log(W_S_des_n[sne]))

@over d(log(W_S_n_13))  = (@year<=2019)*(1  * d(log(P_e))  + d(log(CFS))  + 1  * d(log(PROG_L_13))  - 1.8  * (  - d(L_13(-1)  * ( DLog(GDP_13)  - Dlog(prog_L_13) )  / ( L_13(-1)  / L(-1)  * POP_tot(-1) )) ))+ (@year>2019)* d(log(W_S_des_n[sne]))

#@over d(log(W_S_n[sne])) = 1*d(log(PVA)) + 1*d(log(PROG_L[sne])) + 1*d(log(1/((1-TCSS)*(1-TIR[H01]{-1})))) - 3.2*d(UnR_TOT)      if W_S_n[sne] <> 0


# salaires de CT - secteurs non énergétiques

d(log(W_S_ademe[sne]))  = (ADJUST(18 , 1) * d(log(W_S_n[sne])) + ( 1 - ADJUST(18 , 1) ) * d(log(W_S[sne]{-1})) - ADJUST(18 , 2) * (log(W_S[sne]{-1}/W_S_n[sne]{-1})))

d(log(W_S_dgt[sne]))  = ( 0.5 * d(log(P)) + 0.5 * d(log(P{-1})) + 0.42 * d(log(Y[sne]/L[sne])) - 0.7 * d(UnR_TOT) - 0.27 * (log((W_S[sne]{-1})/W_S_n[sne]{-1})))

@over d(log(W_S[sne]))  =  d(log(W_S_ademe[sne])) * (@year <= 2019) + d(log(W_S_dgt[sne]))* (@year > 2019) # calibrage sur l'équation des salaires des travailleurs qualifiés (la valeur des coefficients étant de toute façon proche de celle des travailleurs non-qualifiés)

#@over d(log(W_S[sne]))  = (ADJUST(18 , 1) * d(log(W_S_n[sne])) + ( 1 - ADJUST(18 , 1) ) * d(log(W_S[sne]{-1})) - ADJUST(18 , 2) * (log(W_S[sne]{-1}/W_S_n[sne]{-1}))) * (@year <= 2019) + ( 0.5 * d(log(P)) + 0.5 * d(log(P{-1})) + 0.42 * d(log(Y[sne]/L[sne])) - 0.7 * d(UnR_TOT) - 0.27 * (log((W_S[sne]{-1})/W_S_n[sne]{-1})))* (@year > 2019) # calibrage sur l'équation des salaires des travailleurs qualifiés (la valeur des coefficients étant de toute façon proche de celle des travailleurs non-qualifiés)


# salaires de CT - secteurs énergétiques

d(log(W_S_ademe[se]))  = (ADJUST(18 , 1) * d(log(W_S_n[se])) + ( 1 - ADJUST(18 , 1) ) * d(log(W_S[se]{-1})) - ADJUST(18 , 2) * (log(W_S[se]{-1}/W_S_n[se]{-1})))

d(log(W_S_dgt[se]))  = (1 * d(log(P)) + 0.42 * d(log(PROG_L[se])) - 0.7 * d(UnR_TOT) - 0.27 * (log((W_S[se]{-1})/W_S_n[se]{-1})))

@over d(log(W_S[se]))  = d(log(W_S_ademe[se]))* (@year <= 2019) + d(log(W_S_dgt[se]))* (@year > 2019) # calibrage sur l'équation des salaires des travailleurs qualifiés (la valeur des coefficients étant de toute façon proche de celle des travailleurs non-qualifiés)


#### MODIFICATION PRIX DE PRODUCTION ####


d(log(PY_des[sdai])) = 0.66 * d(log(NCU_n[sdai])) + 0.07 * d(log(1 + TMD_n[sdai])) - 0.17 * (log(PY_des[sdai]{-1}) - log(PY_n[sdai]{-1}))
d(log(PY_des[sdse])) = 0.49 * d(log(NCU_n[sdse])) + 0.11 * d(log(1 + TMD_n[sdse])) + 0.19 * d(log(NCU_n[sdse]{-1})) - 0.09 * (log(PY_des[sdse]{-1}) - log(PY_n[sdse]{-1}))
d(log(PY_des[sdsa])) = 0.36 * d(log(PY_des[sdsa]{-1})) + 0.11 * d(log(NCU_n[sdsa])) + 0.16 * d(log(1 + TMD_n[sdsa])) - 0.06 * (log(PY_des[sdsa]{-1}) - log(PY_n[sdsa]{-1}))
d(log(PY_des[se])) = 0.70 * d(log(NCU_n[se])) - 0.26 * (log(PY_des[se]{-1}) - log(PY_n[se]{-1}))

@over log(PY[s]) = (@year <= 2019) * (ADJUST(17, 1) * log(PY_n[s]) + (1 - ADJUST(17, 1)) * (log(PY[s]{-1}) + d(log(PY_e[s])))) + (@year > 2019) * ( log(PY[s]{-1}) + d(log(PY_des[s])))


#### MODIFICATION DYNAMIQUE DEMANDE DE TRAVAIL ####

d(log(L_des[sne])) = 0.20 * d(log(L_des[sne]{-1})) + 0.49 * d(log(Y[sne])) - 0.5 * d(log(CL[sne]*PROG_L[sne]/PY[sne])) - 0.64 *(log(L_des[sne]{-1})-log(L_n[sne]{-1}))
@over log(|V|[sne]) = (@year<= 2019) * (ADJUST(1 + $V, 1) * log(|V|_n[sne]) + (1 - ADJUST(1 + $V, 1)) * (log(|V|[sne]{-1}) + d(log(|V|_e[sne])))) + (@year > 2019) *( log(|V|[sne]{-1}) + d(log(L_des[sne])) ) if |V|[sne] <> 0 where V in L

#### MODIFICATION DYNAMIQUE CONSOMMATION ####

d(log(EXP_des[co,h])) = 0.75 * d(log(ARBINC_VAL[h]/P)) - 0.5 * d(R  - infl_FR) - 0.26 * d(UnR_TOT) - 0.33 * (log(EXP_des[co,h]{-1}) - log(EXP_n[co,h]{-1})) if EXP[co,h] <> 0
@over log(EXP[co,h]) = log(EXP_n[co,h])*(@year<=2019) +   (log(EXP[co,h]{-1}) + d(log(EXP_des[co,h])))*(@year>2019)    if EXP[co, h] <> 0


#### INTRODUCTION DYNAMIQUE SUR LES EXPORTATIONS ####

d(log(X_n_des[c])) = d(log(WD[c])) + d(SUBST_X[c]) if X[c] <> 0

d(log(X_des[cdai])) = 0.91*d(log(WD[cdai])) - 0.33*d(log(PX[cdai]/(TC*PWD[cdai]))) - 0.27*(log(X_des[cdai]{-1})-log(X_n_des[cdai]{-1})) if X[cdai] <> 0
@over d(log(X[cdai])) = (@year<=2019)*(d(log(Xexo[cdai]))) + (@year>2019)*(d(log(X_des[cdai]))) if X[cdai] <> 0

d(log(X_des[cservex])) = 0.49*d(log(WD[cservex])) - 0.35*d(log(PX[cservex]/(TC*PWD[cservex]))) - 0.24*(log(X_des[cservex]{-1})-log(X_n_des[cservex]{-1})) if X[cservex] <> 0
@over d(log(X[cservex])) = (@year<=2019)*(d(log(Xexo[cservex]))) + (@year>2019)*(d(log(X_des[cservex]))) if X[cservex] <> 0

#### MODIFICATION DES FACTEURS D AJUSTEMENT #####
 
@over d(log(Y_e[s])) = 0.3 * d(log(Y_e[s]{-1})) + (1 - 0.3) * d(log(Y[s])) + 0.3 * (log(Y[s]{-1}) - log(Y_e[s]{-1}))

@over d(log(PY_e[s]))  = 0.05  * d(log(PY_e[s]{-1}))  + 0.65  * d(log(PY[s]{-1}))  + 0.3  * d(log(PY_n[s]))

# PY_n en ligne avec la v3
@over PY_n[sne] = NCU_n[sne] * (1 + TMD_n[sne]) if Y[sne] > 0
#baisse un peu inflation

#P_e en ligne avec la v3
@over d(log(P_e)) = (@year<=2019) * (ADJUST(68,2)*d(log(P_e{-1})) + (1-ADJUST(68,2))*d(log(P{-1})) - ADJUST(68,6)*log(P_e{-1}/P{-1})) + (@year>2019)* ( 0.3*d(log(P_e{-1})) + (1-0.3)*d(log(P{-1})) - 0.3*log(P_e{-1}/P{-2}))

@over d(log(PARTR_e[sex, age])) = 0.05 * d(log(PARTR_e[sex, age]{-1})) + 0.65 * d(log(PARTR[sex, age]{-1})) + 0.3 * d(log(PARTR_n[sex, age])) if PARTR[sex, age] <> 0

@over d(log(|V|_e[s])) = 0.05 * d(log(|V|_e[s]{-1})) + 0.65 * d(log(|V|[s]{-1})) + 0.3 * d(log(|V|_n[s])) if |V|[s] <> 0 where V in L E MAT

@over log(|V|[c]) = (@year <= 2019) * ( ADJUST(14 + $V, 1) * log(|V|_n[c]) + (1 - ADJUST(14 + $V, 1)) * (log(|V|[c]{-1}) + d(log(|V|_e[c])))) + (@year > 2019) * (0.5 * log(|V|_n[c]) + (1 - 0.5) * (log(|V|[c]{-1}) + d(log(|V|_e[c])))) if |V|[c] <> 0 where V in SD SM

@over d(log(|V|_e[c])) = 0.05 * d(log(|V|_e[c]{-1})) + 0.65 *d(log(|V|[c]{-1})) + 0.3 * d(log(|V|_n[c])) if |V|[c] <> 0 where V in SD SM

#équilibre comptable OK 
# coefficients d'ajustements: 0.8 partout
@over SUBST_K_NE[s]  = 0.8  * SUBST_K_NE_n[s]  + ( 1  - 0.8 )  * SUBST_K_NE[s]{-1}
@over SUBST_K_E[s]  = 0.8  * SUBST_K_E_n[s]  + ( 1  - 0.8 )  * SUBST_K_E[s]{-1}
@over SUBST_|V|[s] = 0.8 * SUBST_|V|_n[s] + (1 - 0.8) * SUBST_|V|[s]{-1} if |V|[s] <> 0 where V in K L E MAT

@over SUBST_CHD[c]  = 0.8 * SUBST_CHD_n[c]  + ( 1  - 0.8 )  * (SUBST_CHD[c]{-1}) if CHD[c] <> 0
@over SUBST_CHM[c] = 0.8 * SUBST_CHM_n[c]  + ( 1  - 0.8)  * (SUBST_CHM[c]{-1}) if CHM[c] <> 0
@over SUBST_GD[c]  = 0.8  * SUBST_GD_n[c]  + ( 1  - 0.8 )  * (SUBST_GD[c]{-1}) if GD[c] <> 0 
@over SUBST_GM[c]  = 0.8  * SUBST_GM_n[c]  + ( 1  - 0.8 )  * (SUBST_GM[c]{-1}) if GM[c] <> 0
@over SUBST_X[c] = 0.8 * SUBST_X_n[c] + (1- 0.8) * (SUBST_X[c]{-1}) if X[c] <> 0
@over SUBST_XD[c] = 0.8  * SUBST_XD_n[c] + (1- 0.8 ) * (SUBST_XD[c]{-1}) if XD[c] <> 0
@over SUBST_XM[c] = 0.8 * SUBST_GM_n[c] + (1- 0.8 ) * (SUBST_XM[c]{-1}) if XM[c] <> 0

# retrait anticipation dividendes et alignement sur autres coef d'ajustement
@over DIV_HH_VAL  = 0.8  * DIV_HH_VAL_n  + ( 1  - 0.8 )  *  DIV_HH_VAL{-1}  + 0* d(DIV_HH_VAL_e) 
@over DIV_GOV_VAL  = 0.8 * DIV_GOV_VAL_n  + ( 1  - 0.8 )  *  DIV_GOV_VAL{-1}  + 0*d(DIV_GOV_VAL_e) 
# ne change rien
@over d(log(DIV_|V|_VAL_e)) = 0.05 * d(log(DIV_|V|_VAL_e{-1})) + 0.65 * d(log(DIV_|V|_VAL{-1})) + 0.3 * d(log(DIV_|V|_VAL_n)) where V in HH GOV

# effet compétitivité prix des exportations en ligne avec Mésange (vs ES_ext_choc = 0.4 avant)
@over d(SUBST_X_n[c]) = (@year<=2022)*(-ES_X($c, 1) * d(log(PX[c]) - log(TC*PWD[c]))) _ 
                        +(@year>2022)*(-ES_X($c, 1)* d(log(PX[c]) - log(TC*PWD[c]))) if X[c] <> 0  #  where c in 05 06 12 13

### distinction prix courants vs prix constants de prix des énergies fossiles ####

# deflateur au lieu de 2% par an (proxy utilisé par l'ademe pour eviter un plantage
@over PWD[ce2] = PWD_constant[ce2]*PGDP + choc_fossile[ce2]
# change pas mal les resultats dans choc d'investissement

#### CORRECTION DESEQ #####
@over K_NE_des_n_19  = ( @year <= 2019 )  * ( K_n_19 > 0 )  * K_NE_n_19{-1}  * ( K_n_19/K_n_19{-1} )  + _
                 ( @year > 2019 )  * (AME_renov_19 *( K_NE_des_n_19{-1} * ( 1 + d(Y_19)/Y_19{-1} - d(PROG_K_19)/prog_K_19{-1} + IMP_BUD_19 * @elem(GDP , %baseyear)/@elem(K_n_19 , %baseyear)  + _
                  Choc_CSC_19  + d(Inv_IRVE)  / K_n_19{-1} + sobre_19 ) + K_n_19{-1}  * d(SUBST_K_NE_19) ) + _ 
                       (1- AME_renov_19)*(K_NE_des_n_19{-1}*(1 - tdec_19) + I_NE_19))

@over K_NE_des_n_20  = AME_renov_20 *(K_NE_des_n_20{-1} * ( 1 + d(Y_20)/Y_20{-1} - d(PROG_K_20)/prog_K_20{-1} + d(INV_road)/K_n_20{-1} + _
                  IMP_BUD_20 * @elem(GDP , %baseyear)/@elem(K_n_20 , %baseyear) + Choc_DACCS) + K_n_20{-1} * d(SUBST_K_NE_20)) + _
                (1- AME_renov_20)*(K_NE_des_n_20{-1}*(1 - tdec_20) + I_NE_20)


#### MODIFICATIONS RELATIVES A LA SIMULATION DE MA PRIME RENOV' ####


#correction double compte de MPR dans le revenu des menages
# prise en compte des dépenses de rénovation payées comptant dans les depenses de logement : on remplace les depenses de renovation en valeur apres deduction de la subvention par les depenses de renovation avant subvention
@over EXP_HOUSING_Val[h,ecl] = ( @year > %baseyear ) * ( DEBT_REHAB_Val[h,ecl]{-1} * (R_I_REHAB[h,ecl]{-1} + R_RMBS_REHAB[h,ecl]{-1} ) + R_CASH_REHAB[h,ecl] * RENOV_VAL[ecl]  + DEBT_NewB_Val[h,ecl]{-1} * ( R_I_NewBUIL[h,ecl]{-1} + R_RMBS_NewBUIL[h,ecl]{-1} )  + R_CASH_NewBUIL[h,ecl] * PNewBUIL[h,ecl] * NewBUIL[h,ecl] + PENER_BUIL[h,ecl] * ENER_BUIL[h,ecl] + choc_PAC_VAL[ecl])   + ( @year =< %baseyear ) * EXP_HOUSING_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )
   
 # dette des menages pour la rénovation : les ménages s'endettent sur une part du montant total des depenses avant subvention et non pas apres subvention  
@over DEBT_REHAB_Val[h,ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_REHAB[h,ecl] ) * DEBT_REHAB_Val[h,ecl]{-1}  + R_LOAN_REHAB[h,ecl] * RENOV_VAL[ecl] ) + (@year =< %baseyear) * DEBT_REHAB_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )

# subventions CEE et MPR ajoutees au RDB
@over DISPINC_VAL[h] = DISPINC_AI_VAL[h] - IR_VAL[h] - AIC_VAL[h] + REDIS_VAL_H + SUB_AUTO_VAL + SUB_REHAB_VAL   

# prix moyen pondéré au m2 des depenses de renovation (pondéré par les types de renov) avant subvention
PREHAB_H01_HS= RENOV_VAL/REHAB_H01

# EXP_13 représente les dépenses en logement a prix constants 2006. Elle evolue en ligne avec les volumes de construction neuve, de renov et autres depenses de logement. 
# EXP_13 sert a calculer EXP_h01 qui ensuite sert a deduire l'epargne du menage (S_H01  = DISPINC_VAL_H01  - PEXP_H01  * EXP_H) avec PEXP_13_H01 qui capture a la fois les dynamiques de prix et de taux de subvention (variable PREHAB_H01[ecl], prix après subvention).
# on veut donc EXP_13 en volume  (prix constants 2006 et hors subvention)pour ne pas capturer les dynamiques de prix et de taux de subvention (deja capture dans PEXP)

# 1. on remplace PREHAB_H01 (prix de rénov après subvention) par PREHAB_H01_HS au cas où une subvention existe avant 2006. Actuellement, il n'y a pas de subvention en 2006 donc PREHAB_H01_HS(2006) = PREHAB_H01(2006). 
# 2. avant 2019 On avait CHD_13  - SUB_REHAB_VAL. pas de sens de soustraire une subvention en valeur. Par conséquent avant 2019 on n'avait pas EXP_13 = CHD_13. De plus la subvention est ensuite deja capturee dans PEXP. Elle était capturée deux fois (dans EXP et dans PEXP) pour deduire l'epargne. 

# consommation de construction a prix constants 2006. 
EXP_13_des =  @elem(PNewBUIL_H01  , 2006)  * NewBUIL_H01  + @elem(PREHAB_H01_HS, 2006)  * REHAB_H01  + (EXP_13_OTH_Val_H01 )/ PCH_13 + choc_PAC

@over EXP_13_H01  = (EXPexo[13])*(@year<=2019)+(EXP_13_H01{-1} * (1 + d(EXP_13_des)/EXP_13_des{-1}))*(@year>2019) 

# CHD_13 représente la consommation de production domestique de construction avant subvention (MPR et CEE) à prix constants 2006. Variable de comptabilité nationale utilisée pour calculer le PIB. 
# On veut pas inclure de dynamique de subvention en valeur qui capturerait les dynamiques de prix de renovation dans cette equation a prix constants. on supprime SUB_REHAB_VAL
@over CHD[13] = ((EXPexo[13]-CHM[13] > 0) * (EXPexo[13] - CHM[13]) + (EXPexo[13] - CHM[13] =< 0) * (0.00001))*(@year<=2019) +(EXP_13-CHM_13)*(@year>2019)     if CHD[13] <> 0


#### CORRECTION DU CALCUL DES COUTS UNITAIRES DE PRODUCTION NOTIONNELS ####

PE_CEE[se] = CEE[se]/(Ener[se] + 0.0001)
PE_CEE_n[se] = CEE[se]/(E_n[se] + 0.0001)

CU_n_des[s] * Y[s] = CK[s] * K_n[s] + CL[s] * L_n[s] * PROG_L[s] + (PE[s] + PE_CEE_n[s] + PE_signal_bis[s]) * E_n[s] + PMAT[s] * MAT_n[s] if Y[s] > 0
  
CU_des[s]*Y[s] = CK[s]*K[s] + CL[s]*L[s]*PROG_L[s] + (PEner[s] + PE_CEE[s] + PE_signal_bis[s])*Ener[s] + PMAT[s]*MAT[s] if Y[s] > 0

d(log(CU_n_bis[s])) = phi_n_k[s]{-1} * d(log(CK[s]/PROG_K[s])) + phi_n_l[s]{-1} * d(log(CL[s])) + phi_n_e[s]{-1} * d(log((PE[s] + PE_CEE_n[s] + PE_signal_bis[s])/PROG_E[s])) + phi_n_mat[s]{-1} * d(log(PMAT[s])) if Y[s] > 0

@over d(log(CU_n[s])) = (@year<=2019) * d(log(CU_n_des[s])) + (@year>2019) * d(log(CU_n_bis[s])) if Y[s] >0

#### INTEGRATION DU PROGRES TECHNIQUES DANS LES TERMES DE SUBSTITUTION ####

phi_K_bis[s] = K[s] * CK[s] / (K[s] * CK[s] + L[s] * PROG_L[s] * CL[s] + E[s] * (PE[s] + PE_CEE[s] + PE_signal_bis[s]) + MAT[s] * PMAT[s])
phi_L_bis[s] = L[s] * PROG_L[s] * CL[s] / (K[s] * CK[s] + L[s] * PROG_L[s] * CL[s] + E[s] * (PE[s] + PE_CEE[s] + PE_signal_bis[s]) + MAT[s] * PMAT[s])
phi_E_bis[s] = (E[s] * (PE[s] + PE_CEE[s] + PE_signal_bis[s])) / (K[s] * CK[s] + L[s] * PROG_L[s] * CL[s] + E[s] * (PE[s] + PE_CEE[s] + PE_signal_bis[s]) + MAT[s] * PMAT[s])
phi_MAT_bis[s] = MAT[s] * PMAT[s] / (K[s] * CK[s] + L[s] * PROG_L[s] * CL[s] + E[s] * (PE[s] + PE_CEE[s] + PE_signal_bis[s]) + MAT[s] * PMAT[s])
 

    @over d(SUBST_K_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CK[s]/PROG_K[s]) - log(CL[s]))                    * phi_l_bis[s]{-1} _
     -eta_K_E[s]     * d(log(CK[s]/PROG_K[s]) - log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s] + PE_signal_E[s])/PROG_E[s]))   * phi_e_bis[s]{-1} _
     -ES_KLEM($s, 3) * d(log(CK[s]/PROG_K[s]) - log(PMAT[s]))                  * phi_mat_bis[s]{-1} _
   if K_n[s] <> 0
   
    @over d(SUBST_E_n[s]) = _
     -eta_K_E[s]     * d(log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s] + PE_signal_E[s])/PROG_E[s]) - log(CK[s]/PROG_K[s]))   * phi_k_bis[s]{-1} _
     -eta_L_E[s]     * d(log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s]) - log(CL[s]))   * phi_l_bis[s]{-1} _
     -ES_KLEM($s, 6) * d(log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s]) - log(PMAT[s])) * phi_mat_bis[s]{-1} _
   if E_n[s] <> 0
   
    @over d(SUBST_L_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CL[s]) - log(CK[s]/PROG_K[s]))                  * phi_k_bis[s]{-1} _
     -eta_L_E[s]     * d(log(CL[s]) - log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s])) * phi_e_bis[s]{-1} _
     -ES_KLEM($s, 5) * d(log(CL[s]) - log(PMAT[s]))                * phi_mat_bis[s]{-1} _
   if L_n[s] <> 0
   
    @over d(SUBST_MAT_n[s]) = _
     -ES_KLEM($s, 3) * d(log(PMAT[s]) - log(CK[s]/PROG_K[s]))                * phi_k_bis[s]{-1} _
     -ES_KLEM($s, 5) * d(log(PMAT[s]) - log(CL[s]))                * phi_l_bis[s]{-1} _
     -ES_KLEM($s, 6) * d(log(PMAT[s]) - log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s])) * phi_e_bis[s]{-1} _
   if MAT_n[s] <> 0
   
    @over d(SUBST_K_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CK[s]/PROG_K[s]) - log(CL[s]))                    * phi_l_bis[s]{-1} _
     -eta_K_E[s]     * d(log(CK[s]/PROG_K[s]) - log((PE[s] + PE_Signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s]))   * phi_e_bis[s]{-1} _
     -ES_KLEM($s, 3) * d(log(CK[s]/PROG_K[s]) - log(PMAT[s]))                  * phi_mat_bis[s]{-1} _
   if K_n[s] <> 0
   
 @over d(SUBST_K_NE_n[s]) = _
     -ES_KLEM($s, 1) * d(log(CK[s]/PROG_K[s]) - log(CL[s]))                    * phi_l_bis[s]{-1} _
     -0     * d(log(CK[s]/PROG_K[s]) - log((PE[s] + PE_signal[s] + PE_CEE[s] + PE_signal_bis[s])/PROG_E[s]))   * phi_e_bis[s]{-1} _
     -ES_KLEM($s, 3) * d(log(CK[s]/PROG_K[s]) - log(PMAT[s]))                  * phi_mat_bis[s]{-1} _
   if K_n[s] <> 0

 @over d(SUBST_K_E_n[s]) = _
     -0 * d(log(CK[s]/PROG_K[s]) - log(CL[s]))                    * phi_l_bis[s]{-1} _
     -eta_K_E[s]      * d(log(CK[s]/PROG_K[s]) - log((PE[s] + PE_signal[s] + PE_CEE[s] + PE_signal_bis[s] + PE_signal_E[s])/PROG_E[s]))   * phi_e_bis[s]{-1} _
     -0 * d(log(CK[s]/PROG_K[s]) - log(PMAT[s]))                  * phi_mat_bis[s]{-1} _
   if K_n[s] <> 0
   
#### MODIFICATION DEMANDE ENERGETIQUE DANS LES SERVICES ####

@over d(log(E_oth_n[ster])) = AME_renov[ster] * (d(log(Y[ster])) + d(SUBST_E[ster]) - d(log(PROG_E[ster])) + d(E_shock_exo[ster])) + (1 - AME_renov[ster]) * (d(log(E_oth_exo[ster])))

#### CROISSANCE DE L'EFFICACITE ENERGETIQUE ####
#@over GR_PROG_E[sne]  = alpha_PROG_E[sne]  + ((d(log(PE[sne] + PE_Signal[sne] + PE_CEE[sne] + PE_signal_bis[sne])))>0) *( alpha_PROG_E_PE[sne]  * ( d(log(PE[sne] + PE_Signal[sne] + PE_CEE[sne] + PE_signal_bis[sne])) )) + ((d(log(PE[sne] + PE_Signal[sne] + PE_CEE[sne] + PE_signal_bis[sne])))<=0) * (0)


#### MISE EN COHERENCE DES FACTEURS DE PONDERATION DANS LES EQUATIONS DE SUBSTITUTION AVEC LE RESTE DU MODELE ET LA V3 ####

kappa_mat_dgt[trsp, s] = (PMAT[trsp, s] * MAT[trsp, s] / (PMAT[s] * MAT[s])) if MAT[trsp, s] <> 0 where (trsp) in (%list_trsp)

 @over d(SUBST_MAT_n[trsp, s]) = sum( -ES_TRANSP_CI($s, cols_mat(trsp, trsp_oth)) * d(log(PMAT[trsp, s]) - log(PMAT[trsp_oth, s])) * _
                                 @elem((MAT[trsp_oth, s] / (MAT[s]) ),2019) if (trsp_oth <> trsp) * (trsp*trsp_oth <> 240) on trsp_oth in %list_trsp) _
                                 if MAT[trsp_cond, s] <> 0 where (trsp, trsp_cond) in (%list_trsp, %list_trsp)

 @over d(SUBST_MAT_n[trsp, s]) = sum( -ES_TRANSP_CI($s, cols_mat(trsp, trsp_oth)) * d(log(PMAT[trsp, s]) - log(PMAT[trsp_oth, s])) * _
                                 kappa_mat_dgt[trsp_oth, s]{-1} if (trsp_oth <> trsp) * (trsp*trsp_oth <> 240) on trsp_oth in %list_trsp) _
                                 if MAT[trsp_cond, s] <> 0 where (trsp, trsp_cond) in (%list_trsp, %list_trsp)

 kappa_X|O1|_dgt[c] = (PX|O1|[c] * X|O1|[c] / (PX[c] * X[c])) if X|O1|[c] <> 0 where O1 in (D M)
 
 @over d(SUBST_X|O1|_n[c]) = -ES_X($c, 2) * d(log(PX|O1|[c]) - log(PX|O2|[c])) * @elem((PX|O2|[c] * X|O2|[c] / (PX[c] * X[c])),2019) if X|O1|[c] <> 0 where (O1, O2) in (D M, M D)

 @over d(SUBST_X|O1|_n[c]) = -ES_X($c, 2) * d(log(PX|O1|[c]) - log(PX|O2|[c])) * kappa_X|O2|_dgt[c]{-1} if X|O1|[c] <> 0 where (O1, O2) in (D M, M D)


@over d(SUBST_E[ce, s]) = 0.8 *  d(SUBST_E_n[ce, s]) + (1 - 0.8) *  d(SUBST_E[ce, s]{-1}) if E[ce, s] <> 0

kappa_e_dgt[ce, s] = (PE[ce, s] * E[ce, s]/ (PEner[s] * Ener[s])) if E[ce, s] <> 0

@over d(SUBST_E_n[ce, s]) = sum( -ES_NRJ($s, cols_ce(ce, ce_oth)) * d(log(PE[ce, s] + PE_Signal[ce, s] + PE_Signal_bis[ce, s]) - log(PE[ce_oth, s] + PE_Signal[ce_oth, s] + PE_Signal_bis[ce_oth, s])) * _
                               kappa_e_dgt[ce_oth, s]{-1} if ce_oth <> ce on ce_oth in %list_com_E) _
                               if E[ce, s] <> 0

@over d(log(E_oth_des[ce, s])) = d(log(E_oth[s])) + d(SUBST_E[ce, s]) if E_oth_des[ce, s] <> 0


#### MODIFICATION DYNAMIQUE DES PRESTATIONS ####

L_SM = L - L_20
W_SM * L_SM = sum(W_S[s] * L_S[s] + W_SE[s] * L_SE[s] on s in %list_sec_Market)

d(log(PRESOC_DOM_U_TETE_DES)) = d(PRESOC_DOM_U_TETE_shock) + 0.47*log(@elem(PRESOC_DOM_U_TETE_DES,2019)/@elem(W_SM,2019)) + 0 - 0.47 * (log(PRESOC_DOM_U_TETE_DES{-1}) - PRESOC_DOM_U_TETE_shock{-1} - log(W_SM{-1}))
PRESOC_DOM_U_VAL_DES = PRESOC_DOM_U_TETE_DES * Un_TOT
@over PRESOC_DOM_U_VAL = (@year<=2019)*(STEADYSTATE(54, 1) * W_S * Un_Tot) + (@year>2019)*(PRESOC_DOM_U_VAL_DES)

d(log(PRESOC_DOM_Oth_VAL_DES)) = d(PRESOC_DOM_Oth_shock) + 0.64*log(@elem(PRESOC_DOM_Oth_VAL_DES,2019)/(@elem(P,2019)*@elem(PROG_L,2019)*@elem(POP_tot,2019))) + 0.64*d(log(P)) - 0.64*(log(PRESOC_DOM_Oth_VAL_DES{-1}) - PRESOC_DOM_Oth_shock{-1} - log(P{-1}) - log(PROG_L{-1}) - log(POP_tot))
@over d(log(PRESOC_DOM_Oth_VAL)) = (@year<=2019)*(STEADYSTATE(53, 1) * d(log(PROG_L)) + d(log(P)) + d(log(POP_tot))) + (@year>2019)*(d(log(PRESOC_DOM_Oth_VAL_DES)))

#### MODIFICATIONS RELATIVES A LA SIMULATION DE LA DECARBONATION DU MIX ENERGETIQUE ####

## Investissements (et stock de capital) des secteurs énergétiques hors électricité
# investissement notionnel sans choc 
d(log(IA_notionnel_noshock[se_noelec])) = dlog(Y[se_noelec]) + d(SUBST_K[se_noelec]) - dlog(PROG_K[se_noelec])  if IA_n[se_noelec] <> 0 
# Investissement observé
d(log(IA_n_des[se_noelec]))  = d(IMP_BUD_niv_bis[se_noelec]) + ( ADJUST(1  , 1)  * dlog(IA_n_des[se_noelec]{-1})  + 1.8  * dlog(Y[se_noelec]) + 0.28  * ( log(IA_notionnel[se_noelec]{-1}) + IMP_BUD_niv_bis[se_noelec]{-1} - log(IA_n_des[se_noelec]{-1}) )  + ADJUST(1, 4) * 0 * d(SUBST_K[se_noelec]) ) if IA_n[se_noelec] <> 0 
@over d(log(IA_n[se_noelec])) = ( @year <= 2019 )  * ( ( IAexo[se_noelec] > 0 )  * ( dlog(IAexo[se_noelec]) ) )  + ( @year > 2019 )  * (d(log(IA_n_des[se_noelec]))) if IA_n[se_noelec] <> 0 
#Réécriture du choc CSC en niveau
Choc_CSC_niv[se_noelec] = CSC_cost * EMS_CSC[se_noelec] #attention dans l'utilisation de ce type de choc : l'unité n'est pas la même que celle de la variable dans laquelle il intervient ensuite (ici CO2 contre euros pour l'investissement) 
# Investissement notionnel avec le choc en niveau
IA_notionnel[se_noelec] = IA_notionnel_noshock[se_noelec] + (@year > 2019) * (Choc_CSC_niv[se_noelec]) if IA_n[se_noelec] <> 0 
# stock de capital notionnel
@over K_n[se_noelec] = (1 - Tdec[se_noelec]) * K_n[se_noelec]{-1} + IA_notionnel[se_noelec] + IMP_BUD_niv[se_noelec] if K[se_noelec] <> 0 

# les investissements des secteurs de l'électricité sont laissés exogènes.

# Stock de capital observé: modélisation du stock de K observé des secteurs du gaz en ligne avec les autres secteurs
@over K[se24] = (1 - Tdec[se24])  * K[se24]{-1}  + IA[se24]

## modification du taux de marge (alignement sur les s) pour ne pas avoir des reactions abruptes face aux chocs de mix energetique   

# part des facteurs de production dans la production en valeur
phi_n_K[se] = K_n[se] * CK[se] / (K_n[se] * CK[se] + L_n[se] * PROG_L[se] * CL[se] + E_n[se] * (PE[se] + PE_CEE_n[se] + PE_signal_bis[se]) + MAT_n[se] * PMAT[se])
phi_n_L[se] = L_n[se] * PROG_L[se] * CL[se] / (K_n[se] * CK[se] + L_n[se] * PROG_L[se] * CL[se] + E_n[se] * (PE[se] + PE_CEE_n[se] + PE_signal_bis[se]) + MAT_n[se] * PMAT[se])
phi_n_E[se] = (E_n[se] * (PE[se] + PE_CEE_n[se] + PE_signal_bis[se])) / (K_n[se] * CK[se] + L_n[se] * PROG_L[se] * CL[se] + E_n[se] * (PE[se] + PE_CEE_n[se] + PE_signal_bis[s]) + MAT_n[se] * PMAT[se])
phi_n_MAT[se] = MAT_n[se] * PMAT[se] / (K_n[se] * CK[se] + L_n[se] * PROG_L[se] * CL[se] + E_n[se] * (PE[se] + PE_CEE_n[se] + PE_signal_bis[se]) + MAT_n[se] * PMAT[se])
# reflechir plus tard sur PE_CEE et sa presence dans ces parts.

# Capacité de production (fonction de production évaluée aux quantités effectives de facteurs, comme dans la V3)
# charbon 
d(log(YCAP_21)) = phi_n_L_21{-1} * d(log(L_21 * PROG_L_21) ) + phi_n_K_21{-1} * d(log(K_21 * PROG_K_21) ) + phi_n_E_21{-1} * d(log(E_21 * PROG_E_21) ) + phi_n_MAT_21{-1} * d(log(MAT_21) ) if YCAP_21 <> 0
# pétrole
d(log(YCAP_2201)) = phi_n_L_2201{-1} * d(log(L_2201 * PROG_L_2201) ) + phi_n_K_2201{-1} * d(log(K_2201 * PROG_K_2201) ) + phi_n_E_2201{-1} * d(log(E_2201 * PROG_E_2201) ) + phi_n_MAT_2201{-1} * d(log(MAT_2201) ) if YCAP_2201 <> 0
d(log(YCAP_2202)) = phi_n_L_2202{-1} * d(log(L_2202 * PROG_L_2202) ) + phi_n_K_2202{-1} * d(log(K_2202 * PROG_K_2202) ) + phi_n_MAT_2202{-1} * d(log(MAT_2202) ) if YCAP_2202 <> 0
#élec
d(log(YCAP[se23])) = phi_n_L[se23]{-1} * d(log(L[se23] * PROG_L[se23]) ) + phi_n_K[se23]{-1} * d(log(K[se23] * PROG_K[se23]) ) + phi_n_E[se23]{-1} * d(log(E[se23] * PROG_E[se23]) ) + phi_n_MAT[se23]{-1} * d(log(MAT[se23]) ) if YCAP[se23] <> 0
# gaz
d(log(YCAP_2401)) = phi_n_L_2401{-1} * d(log(L_2401 * PROG_L_2401) ) + phi_n_K_2401{-1} * d(log(K_2401 * PROG_K_2401) ) + phi_n_E_2401{-1} * d(log(E_2401 * PROG_E_2401) ) + phi_n_MAT_2401{-1} * d(log(MAT_2401) ) if YCAP_2401 <> 0
d(log(YCAP[se24])) = phi_n_L[se24]{-1} * d(log(L[se24] * PROG_L[se24]) ) + phi_n_K[se24]{-1} * d(log(K[se24] * PROG_K[se24]) ) + phi_n_MAT[se24]{-1} * d(log(MAT[se24]) ) if YCAP[se24] <> 0 where se24 in %list_sec_24\ 2401  

# taux d'utilisation des capacités
CUR_bis[se] = Y[se]/YCAP[se]
# taux d'utilisation des capacités corrigé (ECM)
@over d(log(CUR_test[se])) = 0.6 * d(log(CUR_bis[se])) + 0.4 * d(log(CUR_cible[se])) - 0.6 * (log(CUR_test[se]{-1}) - log(CUR_cible[se]{-1}))
#taux de marge
@over dlog(1+TMD_n[se]) = (0.4 * ( dlog(Y[se])-dlog(Y_e[se]{-1})))*(@year<=2019) + ((TMD_n[se]{-1}>0.01)*(0.4 * d(log(CUR_test[se]))) + (TMD_n[se]{-1}<=0.01)*(0.000001)) * (@year > 2019) if Y[se] > 0

#### MODIFICATIONS RELATIVES A LA SIMULATION DES CERTIFICATS D'ECONOMIE D'ENERGIE ####

# MPR vs CEE : deux modes de versement différents
# MPR = les ménages s'acquittent du devis de rénovation avant subvention MPR (avancement des frais). Puis font la demande de subvention MPR et la reçoivent qq semaines plus tard
# CEE = les ménages s'acquittent du devis de rénovation après subvention CEE. Pas d'avancement des frais
# Les deux subventions sont cumulables

# Dépenses de rénovation en valeur après subvention CEE (avant sbvention MPR)
RENOV_VAL_apCEE[ecl] = sum(PREHAB_h01[ecl,ecl2]*(1 - R_SUB_CEE[h,ecl,ecl2])*REHAB_h01[ecl,ecl2] if REHAB_h01[ecl,ecl2] <> 0 on ecl2)

RENOV_VAL_apCEE = (sum( sum(PREHAB_h01[ecl,ecl2]* (1 - R_SUB_CEE[h,ecl,ecl2])* REHAB_h01[ecl,ecl2] if REHAB_h01[ecl,ecl2] <> 0 on ecl2) on ecl))  

# Dette des menages pour la rénovation : les ménages s'endettent sur une part du montant total des depenses apres subvention pour les CEE et avant subvention pour MPR
@over DEBT_REHAB_Val[h,ecl] = (@year > %baseyear) * ( ( 1 - R_RMBS_REHAB[h,ecl] ) * DEBT_REHAB_Val[h,ecl]{-1}  + R_LOAN_REHAB[h,ecl] * RENOV_VAL_apCEE[ecl] ) + (@year =< %baseyear) * DEBT_REHAB_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )

# Dépenses des ménages en logement : paiement comptant des dépenses de rénovation après CEE mais avant MPR
@over EXP_HOUSING_Val[h,ecl] = ( @year > %baseyear ) * ( DEBT_REHAB_Val[h,ecl]{-1} * (R_I_REHAB[h,ecl]{-1} + R_RMBS_REHAB[h,ecl]{-1} ) + R_CASH_REHAB[h,ecl] * RENOV_VAL_apCEE[ecl]  + DEBT_NewB_Val[h,ecl]{-1} * ( R_I_NewBUIL[h,ecl]{-1} + R_RMBS_NewBUIL[h,ecl]{-1} )  + R_CASH_NewBUIL[h,ecl] * PNewBUIL[h,ecl] * NewBUIL[h,ecl] + PENER_BUIL[h,ecl] * ENER_BUIL[h,ecl] + choc_PAC_VAL[ecl])   + ( @year =< %baseyear ) * EXP_HOUSING_Val[h,ecl]{-1} * ( 1 + STEADYSTATE(1,1) )   

# Revenu disponible des ménages: seule la subvention MPR est reçue (subvention CEE deja déduite des dépenses de logements).
@over DISPINC_VAL[h] = DISPINC_AI_VAL[h] - IR_VAL[h] - AIC_VAL[h] + REDIS_VAL_TCO_H + REDIS_VAL_ETS2_H + SUB_AUTO_VAL  + SUB_RENOV_VAL


# A FAIRE run3: modeliser les CEE comme une taxe plutot que dans coût unitaire et exclure industrie de la taxe.

#### CORRECTION BLOC LOGEMENT ####
# taux de renovation par classe energetique.  #initialisé à taux_rehab
@over d(tau_REHAB_2[h,ecl]) = 0.5*d(tau_REHAB_N[h,ecl]) + (1-0.5)*d(tau_REHAB[h,ecl]{-1}) + 0.05 * (tau_REHAB_N[h,ecl]{-1}-tau_REHAB[h,ecl]{-1})  if tau_REHAB[h,ecl] <> 0  
# modifie les niveaux de REHAB AME. 


#### FINANCEMENT DES MESURES PAR PO ####

### COTISATIONS SOCIALES ###

# hausse de taux de cotsoc salariés
choc_tcss = - choc_css /(L_S * W_S)
# hausse de taux de cotsoc indépendants
choc_tcss_se = - choc_css_se /(L_SE * W_SE)
# hausse de taux de cotsoc employeurs
choc_tcse[s] = - choc_cse /(L_S * W_S)
choc_tcse = choc_tcse[s]
@over TCSE[s] = @elem(TCSE[s], %baseyear) + choc_tcse[s]

# revenu disponible avant impot : on exclut les revenus de l'étranger du choc sur le taux de cotsoc
@over DISPINC_AI_VAL = (W_S * L_S) * (1- (TCSS + choc_tcss) ) + SB_ROW * (1- TCSS)+ (W_SE * L_SE) * (1-(TCSS_SE + choc_tcss_se)) + PRESOC_DOM_VAL + FW_VAL + TR_ROW_VAL
@over DISPINC_AI_VAL[h] = (W_S[h] * L_S[h]) * (1-(TCSS[h]+ choc_tcss))  + SB_ROW[h] * (1- TCSS) + (W_SE[h] * L_SE[h]) * (1-(TCSS_SE[h] + choc_tcss_se)) + PRESOC_DOM_VAL[h] + FW_VAL[h] + TR_ROW_VAL[h]

# cotsoc
@over CSS[s] * PCSS[s] = (TCSS + choc_tcss)  * L_S[s] * W_S[s]
@over CSS_SE[s] * PCSS_SE[s] = (TCSS_SE + choc_tcss_se)  * L_SE[s] * W_SE[s]

### IS ###

# choc d'IS ventilés par secteur uniquement sur les secteurs payant l'IS
@over TIS[s] = TIS_exo[s] - (choc_IS[s]+ TAX_CR_VAL[s])/(PRF[s]{-1} * RF[s]{-1} +0.0000001) 

# à faire pour run3: CI électrification des PL a ajouter à l'IS si c'est bien un CI. 

### IR ###
@over d(TIR[h]) = -d((choc_IR)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)


#### MODIFICATIONS FISCALITE CARBONE POUR ISOLER COMPOSANTE CARBONE, ACCISES, ETS1 ET ETS2 #### 
 
dlog(defl_Ttco[ce2]) = dlog(PCH)
@over TCO_VAL[ce2, s] = Ttco[ce2] * PCH * EMS_SEC[ce2, s] * (1 - EXO[ce2, s]) + PE_signal_ETS * PCH * EMS_SEC[ce2, s] * EXO[ce2, s]
@over TCO_VAL[ce2, s] = (Ttco[ce2] + ETS2[s]) * PCH * EMS_SEC[ce2, s] * (1 - EXO[ce2, s]) + PE_signal_ETS * PCH * EMS_SEC[ce2, s] * EXO[ce2, s]  where s in 14 15 16 17 19 20 #13 
@over Ttco_vol[ce2] = Ttco[ce2] 
 
@over tco_val_hh[ce2, h] = (ttco[ce2] + ETS2_hh[ce2]) * pch * ems_hh[ce2, h] ### ajout de l'ets2 qui touchera egalement directement les menages apres discussion avec la DGEC

#@over REDIS_VAL_SEC = TCO_VAL_SEC

REC_VAL_SEC_TCO[ce2, s] = Ttco[ce2] * PCH * EMS_SEC[ce2, s] * (1 - EXO[ce2, s])
REC_VAL_SEC_ETS[ce2, s] = PE_signal_ETS * PCH * EMS_SEC[ce2, s] * EXO[ce2, s] where s in %list_ETS
REC_VAL_SEC_ETS2[ce2, s] = ETS2[s] * PCH * EMS_SEC[ce2, s] * (1 - EXO[ce2, s]) where s in %list_ETS2

ETS2[s] = ETSexo2[s] where s in %list_ETS2
ETS2_hh[ce2] = ETSexo2_hh[ce2]

REC_VAL_SEC_TCO[s] = sum(REC_VAL_SEC_TCO[ce2, s] on ce2)
REC_VAL_SEC_ETS[s] = sum(REC_VAL_SEC_ETS[ce2, s] on ce2) where s in %list_ETS
REC_VAL_SEC_ETS2[s] = sum(REC_VAL_SEC_ETS2[ce2, s] on ce2) where s in %list_ETS2

REC_VAL_SEC_TCO = sum(REC_VAL_SEC_TCO[s] on s)
REC_VAL_SEC_ETS = sum(REC_VAL_SEC_ETS[sets] on sets)
REC_VAL_SEC_ETS2 = sum(REC_VAL_SEC_ETS2[sets2] on sets2)

REC_VAL_TCO_HH[ce2] = ttco[ce2] * pch * ems_hh[ce2, h]
REC_VAL_TCO_HH = sum(REC_VAL_TCO_HH[ce2] on ce2)
REC_VAL_ETS2_HH[ce2] = ETS2_hh[ce2] * pch * ems_hh[ce2, h]
REC_VAL_ETS2_HH = sum(REC_VAL_ETS2_HH[ce2] on ce2)

REDIS_VAL_TCO_H = REC_VAL_TCO_HH

REDIS_VAL_SEC_TCO = REC_VAL_SEC_TCO
REDIS_VAL_SEC_TCO[s] = REC_VAL_SEC_TCO[s]

REDIS_VAL_SEC_ETS = REC_VAL_SEC_ETS
REDIS_VAL_SEC_ETS[s] = REC_VAL_SEC_ETS[s] where s in %list_ETS

REDIS_VAL_ETS2_H = REC_VAL_ETS2_HH

REDIS_VAL_SEC_ETS2 = REC_VAL_SEC_ETS2
REDIS_VAL_SEC_ETS2[s] = REC_VAL_SEC_ETS2[s] where s in %list_ETS

@over DEP_VAL = CL_S[sp]*L_S[sp]*PROG_L[sp] + R_G{-1}*DEBT_G_VAL{-1} + PRESOC_VAL + SUB_RENOV_VAL + SUB_AUTO_VAL + REDIS_VAL_TCO_H + REDIS_VAL_SEC_TCO _
                + REDIS_VAL_SEC_ETS + REDIS_VAL_ETS2_H + REDIS_VAL_SEC_ETS2 + value(E[sp] + MAT[sp] + IY[sp] + IA[sp] _
				+ (G - G[sp]) - ((SUB - SUB_01) + (SY - SY_01))) 

@over REC_VAL  = DIV_GOV_VAL  + IR_VAL  + AIC_VAL  + INC_GOV_OTH_net  - CL_S_20  * L_S_20  * PROG_L_20  + PY_20  * Y_20  + PTAX  * TAX  + PIY  * IY _
                 + PIS  * IS  + PCSE_TOT  * CSE_TOT  + PCSS_TOT  * CSS_TOT  - ( PE_20  * E_20  + PMAT_20  * MAT_20  + PIY_20  * IY_20 ) _ 
				 + REC_VAL_SEC_ETS + REC_VAL_SEC_ETS2 + REC_VAL_ETS2_HH + REC_VAL_TCO_HH + REC_VAL_SEC_TCO

## option 1 MENAGES ET ENTREPRISES ##

@over d(TIR[h]) = -d((choc_IR)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)
@over DISPINC_VAL[h]  = DISPINC_AI_VAL[h]  - IR_VAL[h] - AIC_VAL[h]  + REDIS_VAL_TCO_H + REDIS_VAL_ETS2_H + SUB_AUTO_VAL  + SUB_RENOV_VAL
#@over d(TIR[h]) = -d( (PHI_TCO[h] * TCO_VAL_HH + REDIS_VAL_SEC)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)
#@over d(TIR[h]) = (@year<=2020) * (-d((PHI_TCO[h] * TCO_VAL_HH + REDIS_VAL_SEC)/ DISPINC_AI_VAL[h])) + (@year>2020) * (-d((PHI_TCO[h] * TCO_VAL_HH )/ DISPINC_AI_VAL[h])) + d(TIR_TREND)

#@over TIS[s] = TIS_exo[s] - (0 * REDIS_VAL_SEC{-1}*PY[s]{-1}*Y[s]{-1}/(PY{-1}*Y{-1}) + TAX_CR_VAL[s])/(PRF[s]{-1} * RF[s]{-1} +0.0000001)
#@over TIS[s] = TIS_exo[s] - (TCO_VAL_SEC[s]{-1} + TAX_CR_VAL[s])/(PRF[s]{-1} * RF[s]{-1} +0.0000001)
@over TIS[s] = TIS_exo[s] - (choc_IS{-1}*PY[s]{-1}*Y[s]{-1}/(PY{-1}*Y{-1}) + TAX_CR_VAL[s])/(PRF[s]{-1} * RF[s]{-1} +0.0000001) 
@over RF_net[s] = @elem(PRF[s]{-1},%baseyear) * RF[s]{-1} - IS[s] + (@year>2020) * (REDIS_VAL_SEC_TCO[s]{-1} + REC_VAL_SEC_ETS[s]{-1} + REDIS_VAL_SEC_ETS2[s]{-1})/PCH{-1}) if RF_net[s] <> 0
@over PRF_net[s] * RF_net[s] = PRF[s]{-1} * RF[s]{-1} - PIS[s] * IS[s] + (REDIS_VAL_SEC_TCO[s]{-1} + REDIS_VAL_SEC_ETS[s]{-1} + REDIS_VAL_SEC_ETS2[s]{-1}) if RF_net[s] <> 0

## option 2 MENAGES UNIQUEMENT ##

#@over d(TIR[h]) = -d((PHI_TCO[h] * REDIS_VAL_H + REDIS_VAL_SEC_TCO + choc_IR)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)
#@over RF_net[s] = @elem(PRF[s]{-1},%baseyear) * RF[s]{-1} - IS[s] if RF_net[s] <> 0
#@over PRF_net[s] * RF_net[s] = PRF[s]{-1} * RF[s]{-1} - PIS[s] * IS[s] if RF_net[s] <> 0

## option 3 PAS DE REDISTRIBUTION ##

#@over d(TIR[h]) = -d((choc_IR)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)
#@over RF_net[s] = @elem(PRF[s]{-1},%baseyear) * RF[s]{-1} - IS[s] if RF_net[s] <> 0
#@over PRF_net[s] * RF_net[s] = PRF[s]{-1} * RF[s]{-1} - PIS[s] * IS[s] if RF_net[s] <> 0
#@over DISPINC_VAL[h]  = DISPINC_AI_VAL[h]  - IR_VAL[h] - AIC_VAL[h] + SUB_AUTO_VAL  + SUB_RENOV_VAL
#@over DEP_VAL = CL_S[sp]*L_S[sp]*PROG_L[sp] + R_G{-1}*DEBT_G_VAL{-1} + PRESOC_VAL + SUB_RENOV_VAL + SUB_AUTO_VAL _
#                + value(E[sp] + MAT[sp] + IY[sp] + IA[sp] + (G - G[sp]) - ((SUB - SUB_01) + (SY - SY_01))) 

## option 4 MENAGE ET ENTREPRISES (TCSE) ##

#@over d(TIR[h]) = -d((choc_IR)/ DISPINC_AI_VAL[h]) + d(TIR_TREND)
#@over DISPINC_VAL[h]  = DISPINC_AI_VAL[h]  - IR_VAL[h] - AIC_VAL[h]  + REDIS_VAL_TCO_H  + SUB_AUTO_VAL  + SUB_RENOV_VAL
#@over TIS[s] = TIS_exo[s] - (choc_IS{-1}*PY[s]{-1}*Y[s]{-1}/(PY{-1}*Y{-1}) + TAX_CR_VAL[s])/(PRF[s]{-1} * RF[s]{-1} +0.0000001) 
#@over RF_net[s] = @elem(PRF[s]{-1},%baseyear) * RF[s]{-1} - IS[s] if RF_net[s] <> 0
#@over PRF_net[s] * RF_net[s] = PRF[s]{-1} * RF[s]{-1} - PIS[s] * IS[s] if RF_net[s] <> 0
#@over TCSE[s] = @elem(TCSE[s], %baseyear) - REDIS_VAL_SEC_TCO{-1}/(W_S{-1} * L_S{-1})

@over PENERTD[ce] * ENERTD[ce] = TTICD[ce] * YQ[ce] if ENERTD[ce] <> 0 ## pourquoi les taxes energetiques ne sont-elles pas calculees par rapport a la production en prix courants PYQ * YQ comme les autres taxes ?
@over PENERTM[ce] * ENERTM[ce] = TTICM[ce] * M[ce] if ENERTM[ce] <> 0 ## idem
@over YQ[ce] * PYQ[ce] = PQD[ce] * QD[ce] - PVATD[ce] * VATD[ce] - POTHTD[ce] * OTHTD[ce] - PSUBD[ce] * SUBD[ce] - (PMCD[ce] * MCD[ce] + PMTD[ce] * MTD[ce]) - PENERTD[ce] * ENERTD[ce] - TCO_VALD[ce] if YQ[ce] <> 0
@over M[ce] * PM[ce] = PQM[ce] * QM[ce] - PVATM[ce] * VATM[ce] - POTHTM[ce] * OTHTM[ce] - PSUBM[ce] * SUBM[ce] - (PMCM[ce] * MCM[ce] + PMTM[ce] * MTM[ce]) - PENERTM[ce] * ENERTM[ce] - TCO_VALM[ce] if M[ce] <> 0
@over PYQS[ce]  * YQS[ce]  = PYQ[ce]  * YQ[ce]  + POTHTD[ce]  * OTHTD[ce]  + PENERTD[ce]  * ENERTD[ce]  + PSUBD[ce]  * SUBD[ce]  + PMTD[ce]  * MTD[ce]  + PMCD[ce]  * MCD[ce] + TCO_VALD[ce] if YQS[ce] <> 0
@over PMS[ce]  * MS[ce]  = PM[ce]  * M[ce]  + POTHTM[ce]  * OTHTM[ce]  + PENERTM[ce]  * ENERTM[ce]  + PSUBM[ce]  * SUBM[ce]  + PMTM[ce]  * MTM[ce]  + PMCM[ce]  * MCM[ce] + TCO_VALM[ce] if MS[ce] <> 0

@over PGDPter  * GDPter  = PVA  * VA  + PTAX  * TAX  + PSUB  * SUB + REC_VAL_TCO_HH + REC_VAL_ETS2_HH + REC_VAL_SEC_TCO + REC_VAL_SEC_ETS + REC_VAL_SEC_ETS2


 @over EXPG = ( 1 + ADJUST(69,1)*(d(log(EXPG_trend)) - STEADYSTATE(62,1)*(DP_G_VAL - DP_G_VAL_n)*PGDP{-1}*GDP{-1} / (PG{-1}*EXPG{-1})) + _
              (1-ADJUST(69,1))*dlog(EXPG{-1}))*EXPG{-1}
  
##########################################################
################ MODIFICATIONS EVAL SNBC3 ################
##########################################################

#### Modification pour tableaux de sorties ####

MAT := sum (MAT[s] if MAT[s]<>0 on s)
#PMAT := sum (PMAT[s]*MAT[s] if MAT[s]<>0 on s) #error
PMAT * MAT := sum (PMAT[s]*MAT[s] if MAT[s]<>0 on s)

w_s_spb:= sum(W_S[s]*(1 + TCSE[s])*L_S[s]/L_s on s)
w_spb := w_s_spb * L_s/L + w_se*L_se/L

CL_S_bis[s] :=  CL_S[s]* PROG_L[s] 
CL_SE_bis[s] := CL_SE[s]* PROG_L[s] 
CL_S_bis := (sum(CL_S_bis[s] * L_S[s] on s))/L_S
CL_SE_bis := (sum(CL_SE_bis[s] * L_SE[s] on s))/L_SE
CL_bis  * L  := ( CL_S_bis  * L_S  + CL_SE_bis  * L_SE )

##### MODIFICATION DU COUT DU CAPITAL #####

#@over CK[sne] := PK[sne] * (Tdec[sne] + RK[sne] - d(PK[sne])/PK[sne]{-1}) if K[sne] > 0   
#@over CK[s] := PIA[s] * (Tdec[s] + RK[s] - d(PIA[s])/PIA[s]{-1}) if K[s] > 0
@over CK[s] := PK[s]* (Tdec[s] + RK[s] - d(PIA[s])/PIA[s]{-1})

##### INVESTISSEMENT ##### 
Ibis[sne] := IA_n[sne]
Ibis_bis[sne] := IA_n[sne]
IMP_BUD_bis[sne] := 0

#IMP_BUD_20_bis := 0
#Kbis_n_20 := K_n_20
#CHOC_K_20 := 0
#@over IA_des[s] := IA[s]

# ajout des intérêts au stock de dette des ménages (uniquement pour affichage, cahier de variantes)
# pour le GOV ils sont inclus dans le deficit qui est utilise pour calculer la dette
DEBT_REHAB_Val_tot[h,ecl] :=  DEBT_REHAB_Val[h,ecl] + DEBT_REHAB_Val[h,ecl]{-1}*R_I_REHAB[h,ecl]{-1} 
DEBT_NewB_Val_tot[h,ecl] := DEBT_NewB_Val[h,ecl] + DEBT_NewB_Val[h,ecl]{-1}*R_I_NewBUIL[h,ecl]{-1}  
DEBT_AUTO_Val_tot[h,ecl] := DEBT_AUTO_Val[h,ecl] + DEBT_AUTO_Val[h,ecl]{-1}*R_I_AUTO[h,ecl]{-1}  


#### PRIX DES IMPORTATIONS ####

YQS_SM := sum(YQS[cbienmar] on cbienmar)
PYQS_SM := sum(YQS[cbienmar]*PYQS[cbienmar]/YQS_SM on cbienmar)
GRPM_01:=0
GRPM[sind]:=0
GRPM[cservex]:=0
GRPM[ce]:=0


#### VOLUMES DES IMPORTATIONS ####
  
 @over MAT_n[sne] := sum(MAT_n[cm,sne] on cm)
 
 #@over MAT_des[sne] = MAT_n[sne]
 
 MATM_des[cm,sne]  :=  MATM[cm,sne]
 
 MATD_des[cm,sne] := MATD[cm,sne]
 
 MATD_n[cm,sne] := MATD[cm,sne]

 MATM_n[cm,sne] := MATM[cm,sne]
 
 MAT_des[cm,sne] := MATD_des[cm, sne] + MATM_des[cm, sne]
 
 verif_MAT[s] := MAT[s] - MATD[s]-MATM[s]
 
 verif_MAT[cm,s] := MAT[cm,s] - MATD[cm,s]-MATM[cm,s]
 
 
############
#error 
GRMATM[cdai,sne] := 0
GRMATM[cdaicim,sepeg] := 0
#GRMATM[cservex,sne] := 0
GRMATM[cservex,sepeg] := 0
GRCHM[cdai] := 0
GRCHM[cservex] := 0
GRCHM[cepeg] := 0
GRGM[cdai] := 0
GRGM[cservex] := 0
GRIAM[cdai,sne] := 0
GRIAM[cservex,sne] := 0
#GRDSM[cdai] := 0
#GRDSM[cservex] := 0
GREM[eno21,s] := 0
GRMATM[cservex,sne] := STEADYSTATE(2, 1)
GRMATM_n[cservex,sne] := STEADYSTATE(2, 1)

#### TAUX DE MARGE DE THREEME V3 ####

CUR_test[sne] := Y[sne] / YCAP_test[sne]
YCAP_test[sne] := Y[sne] / 0.8 ### calibrage de ThreeME V3


##########################################################
############ AUTRES MODIFICATIONS DESACTIVEES ############
##########################################################


#### PRIX DES EXPORTATIONS ####

#PXD_n[c] := PXD[c] where c in 01 02 03 04 05 06 07 08 09 10 11 12 14 16 17 18 19
PXD_n[c] := P 


#### VOLUMES DES EXPORTATIONS ####

#X_n[c] := X[c] where c in 01 02 03 04 05 06 07 08 09 10 11 12 14 16 17 18 19

GR_X_temp[cdai]:= (0.86 * d(log(WD[cdai])) - 0.22 * (d(log(PXD[cdai]))-d(log(PXM[cdai]))) - 0.11 * (log(X[cdai]{-1}) - log(WD[cdai]{-1}) + 0.77 * (log(PXD[cdai]{-1})-log(PXM[cdai]{-1})))) if X[cdai] <>0
GR_X_temp[cservex]:= (0.27 * d(log(WD[cservex])) + 0.19 * d(log(WD[cservex]{-1})) - 0.23 * (d(log(PXD[cservex]))-d(log(PXM[cservex]))) - 0.08 * (log(X[cservex]{-1}) - log(WD[cservex]{-1}) + 0.81 * (log(PXD[cservex]{-1})-log(PXM[cservex]{-1})))) if X[cservex] <>0
GR_X_temp[ce]:= (0.89 * d(log(WD[ce])) - 0.3 * (log(X[ce]{-1}) - log(WD[ce]{-1})))  if X[ce] <>0


#### VOLUMES DES EXPORTATIONS ####

#X_n[c] := X[c] where c in 01 02 03 04 05 06 07 08 09 10 11 12 14 16 17 18 19

PYX_des[s] := P

PYX_n[s] := P

PYX[s] := P

YD[s] := Y[s] - YX[s]  #YD est la production vendue sur le marché domestique

PYD[s] := P

PYD_n[s] := P

YX[s] := sum(YX[c,s] on c)   #YX est la production domestique exportée. Limite du modèle, les taux de TVA et autres taxes et subventions à la consommation sont les mêmes pour les produits consommés domestiquement et les exports

#YX[c,s]*QD[c] := Y[c,s]*XD[c] if QD[c]>0 #limite du modèle : on connait les exports par produit mais pas par filière. On suppose que les exports des produits des filières sont égaux au prorata des exports par produits. 

YX[c,s] := PhiY[c,s]*XQ[c] 

PXQ[c] := P

#XQ[c] := sum(YX[c,s] on s)

XQ[c]*PXQ[c] := PXD[c]*XD[c] + (- POTHTD[c]  * OTHTD[c]  - PSUBD[c]  * SUBD[c]  -  (PMCD[c]  * MCD[c]  + PMTD[c]  * MTD[c]) - PENERTD[c]  * ENERTD[c])*XD[c]/QD[c] 

PXQS[c] := P

XQS[c] := XQ[c] + OTHTXD[c] + ENERTXD[c] + SUBXD[c] + MTXD[c] + MCXD[c]  

OTHTXD[c] := @elem(TOTHTXD[c] , 2006)  * XQ[c]

POTHTXD[c]  := P

TOTHTXD[c] := TOTHTD[c]  # à modifier ultérieurement si données disponibles. Auquel cas il faudra créer une équation OTHTYD et OTHTYD et modifier l'équation de OTHTD

ENERTXD[c] := @elem(TTICXD[c], %baseyear) * XQ[c] 

PENERTXD[c] := P

TTICXD[c] := TTICD[c] # à modifier ultérieurement si données disponibles Auquel cas il faudra créer une équation TTICYD et TICYD et modifier l'équation de TICD

TCO_VALXD[c]*YQ[c] := TCO_VALD[c] * XQ[c] if YQ[c]>0

SUBXD[c]  := @elem(TSUBXD[c] , 2006)  * XQ[c]

PSUBXD[c] := P

TSUBXD[c] := TSUBD[c] # à modifier ultérieurement si données disponibles. Auquel cas il faudra créer une équation TSUBYD et SUBYD et modifier l'équation de SUBD

PMTXD[c] := P

PMTXD[s,c] := PXD[s] where s in 14 16 17 18

PMCXD[c] := P

MTXD[c] := MTXD_14[c] + MTXD_16[c] + MTXD_17[c] + MTXD_18[c] 

#sum(MTXD[s,c] on s) where s in 14 16 17 18

#MTXD[s,c]*YQ[c] := 0 +((MTD[s,c] * XQ[c])>0) * (MTD[s,c] * XQ[c]) if YQ[c]>0  where s in 14 16 17 18
MTXD[s,c] := (0+(MTD[s,c]>=0)*MTD[s,c])*XQ[c]/YQ[c] if YQ[c]>0  where s in 14 16 17 18


MCXD[c]*YQ[c] := MCD[c]*XQ[c] if YQ[c]>0

#PXQS[c]*XQS[c] * YQ[c] := PYQS[c]*YQS[c]*XQ[c]  if XQS[c] * YQ[c] > 0  

#XQS[c]*YQ[c] := (YQ[c] + OTHTD[c] + ENERTD[c] + SUBD[c] + MTD[c] + MCD[c])*XQ[c]  if YQ[c] > 0

PXD[c] := P

#verif_XQbis_XQ[c] := 0
#verif_Ybis_YQbis := Y-YQ

##### salaires #####
#prix de VA anticipe
pva_e := p

##### PART DES DEPENSES INCOMPRESSIBLES DE SERVICES NON MARCHANDS

#@over NEXP_20_h01 := EXP_20_h01 * 0.86 #source Insee sans devoir modifier le fichier SAM_FRA_AME-AMS/Household

#### AJOUTS CHOCS DGT POUR CAHIER DE VARIANTES####

CHOC_K := 0
CHOC_PGF := 0 
CHOC_L := 0
CHOC_E := 0
choc_fossile[ce2]:=0

IMP_BUD_niv[sne]:=0
IA_notionnel_noshock[sne]:=IA_n[sne]
IA_notionnel[sne]:=IA_n[sne]
IA_n_noshock[sne]:=IA_n[sne]
IA_n_noshock_03[road] := IA_n_03[road]
IA_n_noshock_12[road] := IA_n_12[road]


#### CORRECTION FORMULE RATIO D'UTILISATION DES CAPACITES
phi_n_K[sne] := phi_K[sne]
phi_n_L[sne] := phi_L[sne]
phi_n_E[sne] := phi_E[sne]
phi_n_MAT[sne] := phi_MAT[sne]

YCAP[sne] := Y[sne] / 0.8 ### calibrage de ThreeME V3
CUR[sne] := Y[sne] / YCAP[sne]

#### arbitrage consommation en volume
EXP_CES_VOL := sum((EXP_n[co, h] - NEXP[co, h] ) on co)

CHD_des[c] := CHD[c]

CHM_des[c] := CHM[c]

CH_des[c] := CHD_des[c] + CHM_des[c]

CH_n[c] := CH[c]  

CHD_n[c] := CHD[c]  

CHM_n[c] := CHM[c]  

GM_des[c] := GM[c]

 GD_des[c]  := GD[c]
                    
 G_des[c] := GD_des[c] + GM_des[c]  
 
 GM_n[c]  := GM[c]
 
 GD_n[c] := GD[c]

 G_n[c] := G[c]
 
 IAM_d[c,sne] := IAM[c,sne]

 IAD_d[c,sne]  := IAD[c,sne]
                    
 IA_d[c,sne] := IAD_d[c,sne] + IAM_d[c,sne]  
 
 IAM_n[c,sne]  := IAM[c,sne]
 
 IAD_n[c,sne] := IAD[c,sne]

 IA_n[c,sne] := IA[c,sne]
 
 GRMATM_CT[c,s] := STEADYSTATE(2, 1)
                                                  
 GRMATM_LT[c,s] := STEADYSTATE(2, 1)
 
 MATM_CT[cm,sne] := MATM[cm,sne]
 
 MATM_LT[cm,sne] := MATM[cm,sne]
 
 GRCHM_CT[c] := STEADYSTATE(2, 1) 

CHM_CT[c] := CHM[c] 
                                                  
GRCHM_LT[c] := STEADYSTATE(2, 1)

CHM_LT[c] := CHM[c]  

@over GRCHM[c] :=  STEADYSTATE(2, 1)

 GRGM_CT[c] := STEADYSTATE(2, 1) 

GM_CT[c] := GM[c] 
                                                  
GRGM_LT[c] := STEADYSTATE(2, 1)

GM_LT[c] := GM[c]  

@over GRGM[c] :=  STEADYSTATE(2, 1)  

GRIAM_CT[cm,sne] := STEADYSTATE(2, 1)   

IAM_CT[cm,sne] :=  IAM[cm,sne] 
                                                  
GRIAM_LT[cm,sne] := STEADYSTATE(2, 1)

IAM_LT[cm,sne] := IAM[cm,sne] 

@over GRIAM[cm,sne] :=  STEADYSTATE(2, 1)  
  
